<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ci on Martin Liu's Blog</title><link>https://martinliu.cn/tags/ci/</link><description>Recent content in Ci on Martin Liu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 18 Sep 2025 17:26:30 +0800</lastBuildDate><atom:link href="https://martinliu.cn/tags/ci/index.xml" rel="self" type="application/rss+xml"/><item><title>2025 年别再使用 Jenkins！</title><link>https://martinliu.cn/blog/stop-using-jenkins-in-2025/</link><pubDate>Thu, 28 Aug 2025 10:00:00 +0800</pubDate><guid>https://martinliu.cn/blog/stop-using-jenkins-in-2025/</guid><description>&lt;img src="https://martinliu.cn/blog/stop-using-jenkins-in-2025/1_9wQ57gpbdI9JwUHpJmtFdA.jpeg" alt="Featured image of post 2025 年别再使用 Jenkins！" />&lt;h2 id="阻碍你前进的遗留巨头">阻碍你前进的遗留巨头
&lt;/h2>&lt;p>认识一下 Janet。她是一家中型科技公司的 DevOps 工程师，工作了五年。每个周一早上，她都会像闹钟一样，为不可避免的事情做好准备：“Jenkins 服务器又宕机了。”或者“构建失败了，没人知道为什么。”又或者她最喜欢的那句，“我们需要更新所有的 Jenkins 插件，但我们担心一切都会崩溃。”&lt;/p>
&lt;p>听起来很熟悉？你并不孤单。&lt;/p>
&lt;p>Jenkins 在过去的 15 年里一直是首选的 CI/CD 工具。它就像那辆老旧的家庭汽车，虽然总是进修理店，但你仍然保留着，因为，嗯，你习惯了它。但正如你在 2025 年不会再使用翻盖手机一样，现在或许是时候重新审视你与 Jenkins 的关系了 😒。&lt;/p>
&lt;h2 id="为什么-jenkins-正在显露老态">为什么 Jenkins 正在显露老态
&lt;/h2>&lt;p>Jenkins 在 2005 年推出时是革命性的。但 iPod 也是。技术发展迅速，曾经的尖端产品很快就会过时。以下是 Jenkins 正在落后的原因：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>让安全团队彻夜难眠的安全漏洞: Jenkins 有着令人不安的安全问题历史。仅在 2021 年，Jenkins 安全团队就披露了 30 多个漏洞，并且新的漏洞还在不断出现。许多组织以提升的权限运行 Jenkins，这使得这些漏洞尤为危险。以 Acme Corp（化名）为例。他们的 Jenkins 实例通过 CVE-2023–27898 被攻破，这是一个在脚本安全插件 (Script Security Plugin) 中的关键漏洞。攻击者获得了他们生产凭证的访问权限，并在其基础设施中部署了加密货币挖矿程序 (crypto miners)。清理工作让他们花费了三天的工程时间，并损害了客户信任。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拖慢整个团队效率的性能问题: “我趁构建运行的时候去喝杯咖啡”这不仅仅是开发人员的玩笑，更是一个生产力问题。Jenkins 实例通常会随着时间的推移变得越来越慢，特别是当你添加更多作业和插件时。Michael，一个游戏初创公司的开发人员，描述了他的经历：“我们的 Jenkins 构建以前需要 10 分钟。在增加了两年功能和测试之后，它们需要 45 分钟。我们花在等待 Jenkins 上的时间比实际编码的时间还要多。”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>滋生“Jenkins 专家”的配置复杂性: Jenkins 的灵活性是有代价的：复杂性。组织往往最终只有一两个“Jenkins 大师”，他们是唯一了解一切如何运作的人。当他们去度假或离开公司时，恐慌就会随之而来。一位工程经理曾这样说：“我们有超过 200 个 Jenkins 流水线，每个的配置都略有不同。没人敢碰它们，因为我们担心它们会中断。这简直是最纯粹的技术债。”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消耗资源的维护开销: 自行托管的 Jenkins 需要持续维护。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>你需要：&lt;/p>
&lt;ul>
&lt;li>管理 Jenkins 服务器本身&lt;/li>
&lt;li>定期更新 Jenkins 核心&lt;/li>
&lt;li>更新几十甚至上百个插件&lt;/li>
&lt;li>处理备份和灾难恢复&lt;/li>
&lt;li>配置和维护构建代理 (build agents)&lt;/li>
&lt;/ul>
&lt;p>这些维护工作不会增加业务价值；它只是为了维持系统运行。&lt;/p>
&lt;h2 id="github-actions现代替代方案">GitHub Actions：现代替代方案
&lt;/h2>&lt;p>Janet 的故事有一个圆满的结局。她的团队从 Jenkins 迁移到了 GitHub Actions，周一早上的“救火”式应对也成为了历史。&lt;/p>
&lt;p>GitHub Actions 代表了一种截然不同的持续集成/持续部署 (CI/CD) 方法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>内置安全性，无需维护服务器 : GitHub Actions 在 GitHub 的云中运行。你无需担心 Jenkins 服务器的安全或应用安全补丁。GitHub 的安全团队会为你处理这些。最好的安全服务器是你根本无需管理的服务器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自动扩展的性能 ： 需要更多构建能力？GitHub Actions 会自动扩展以满足需求。你可以并行运行构建，而无需管理额外的构建代理。Janet 的团队在迁移到 GitHub Actions 后，构建时间缩短了 60%，仅仅是因为他们可以并行执行测试，而无需担心基础设施 (infrastructure) 限制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>人人都能理解的代码化配置：GitHub Actions 使用直接存储在你的代码仓库 (repository) 中的 YAML 文件。这种方法有几个优点：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>配置与它所构建的代码共存&lt;/li>
&lt;li>变更通过常规代码审查 (code reviews) 进行追踪&lt;/li>
&lt;li>新团队成员可以快速理解设置&lt;/li>
&lt;li>无需专业知识&lt;/li>
&lt;/ul>
&lt;p>一位开发人员报告说：“GitHub Actions 的学习曲线比 Jenkins 平缓得多。我可以在一个下午，而不是几周内，理解我们整个 CI/CD 流水线。”&lt;/p>
&lt;ol start="4">
&lt;li>零维护开销 ：使用 GitHub Actions，你将拥有：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>无需维护服务器&lt;/li>
&lt;li>无需更新插件&lt;/li>
&lt;li>无需配置构建代理&lt;/li>
&lt;li>无需管理备份&lt;/li>
&lt;/ul>
&lt;p>这让工程师可以将时间投入到实际的产品开发中，而不是基础设施的维护。&lt;/p>
&lt;p>&lt;strong>实际影响&lt;/strong>&lt;/p>
&lt;p>让我告诉你 Realtime Analytics, Inc. 从 Jenkins 切换到 GitHub Actions 后发生了什么。&lt;/p>
&lt;p>在切换之前，他们有：&lt;/p>
&lt;ul>
&lt;li>两名全职工程师专门负责 Jenkins 维护&lt;/li>
&lt;li>每周发生的故障影响开发者生产力&lt;/li>
&lt;li>平均构建时间 35 分钟&lt;/li>
&lt;li>定期出现安全隐患，需要紧急修补&lt;/li>
&lt;/ul>
&lt;p>切换到 GitHub Actions 六个月后：&lt;/p>
&lt;ul>
&lt;li>两名工程师都被重新分配到产品开发工作&lt;/li>
&lt;li>零 CI/CD 故障&lt;/li>
&lt;li>构建时间缩短到 12 分钟&lt;/li>
&lt;li>安全问题由 GitHub 自动处理&lt;/li>
&lt;/ul>
&lt;p>他们的 CTO 估算，仅工程时间一项，这项改变每年就为他们节省了大约 30 万美元，这还不包括改善的开发者体验和更快的上市时间。&lt;/p>
&lt;h2 id="切换比你想象的更容易">切换：比你想象的更容易
&lt;/h2>&lt;p>从 Jenkins 迁移到 GitHub Actions 的想法可能看起来令人生畏，但实际上它比你想象的要简单直接得多。&lt;/p>
&lt;p>这里有一个简化的方法：&lt;/p>
&lt;ol>
&lt;li>从一个小型、非关键项目开始&lt;/li>
&lt;li>将其 Jenkins 流水线 (pipeline) 转换为 GitHub Actions 工作流 (workflow)&lt;/li>
&lt;li>并行运行这两个系统以建立信心&lt;/li>
&lt;li>随着团队适应，逐步迁移更多项目&lt;/li>
&lt;/ol>
&lt;p>GitHub 甚至专门为 Jenkins 用户提供了迁移指南和示例。&lt;/p>
&lt;h2 id="github-actions-完美吗不但它是一个重大改进">GitHub Actions 完美吗？不，但它是一个重大改进
&lt;/h2>&lt;p>公平地说，GitHub Actions 并非没有局限性：&lt;/p>
&lt;ul>
&lt;li>对于非常专业的构建要求，你可能需要定制解决方案&lt;/li>
&lt;li>如果你没有使用 GitHub 进行源代码管理 (source control)，集成就不会那么无缝&lt;/li>
&lt;li>一些复杂的 Jenkins 设置可能需要你重新思考方法&lt;/li>
&lt;/ul>
&lt;p>然而，对于绝大多数开发团队来说，GitHub Actions 几乎在所有方面都代表着对 Jenkins 的巨大改进。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>&lt;strong>Jenkins 多年来一直为我们服务得很好&lt;/strong>，但软件开发已经演进。现代的 CI/CD (持续集成/持续交付) 解决方案，例如 GitHub Actions，专为当今的开发实践而设计：云原生 (cloud-native)、注重安全，并优化了开发者生产力 (developer productivity)。&lt;/p>
&lt;p>正如 Janet 所发现的，最初的迁移努力会迅速带来回报。她的团队现在部署更频繁，问题更少，并且几乎不花时间维护他们的 CI/CD 基础设施。&lt;/p>
&lt;p>&lt;strong>问问自己：&lt;/strong> 上个月你的团队花了多少时间与 Jenkins 搏斗？如果把这些时间用于其他工作，你本可以构建出什么？&lt;/p>
&lt;p>CI/CD 的未来已经到来。&lt;strong>也许&lt;/strong>是时候让 Jenkins 成为过去式了。&lt;/p></description></item><item><title>10 分钟读懂 DevOps 工具链</title><link>https://martinliu.cn/blog/10-minute-read-to-understanding-devops-tools/</link><pubDate>Fri, 02 Apr 2021 22:34:09 +0800</pubDate><guid>https://martinliu.cn/blog/10-minute-read-to-understanding-devops-tools/</guid><description>&lt;img src="https://martinliu.cn/img/cos/2021-04-03-eggs-3216877_1920.jpeg" alt="Featured image of post 10 分钟读懂 DevOps 工具链" />&lt;p>【译文】上周，我和我的几位非常资深的同事都在评论说，有很多新的DevOps工具正在出现，而且每天都越来越难跟踪它们，以及它们在DevOps 领域的定位。我问了他们几个工具，Ansible、Terraform、Salt、Chef、Bamboo、CloudFormation这些工具的定位在哪里？我为什么要用这个而不是那个？它们甚至是同一种东西吗？我是不是漏掉了一个主要角色？我得到了什么，一些白眼和问题。所以，我想我会做一些研究，阅读，并试图让我们所有人理解它，以便我们可以将那些产品都分类到我们都熟悉的类别或用途。&lt;/p>
&lt;p>原文：&lt;a class="link" href="https://levelup.gitconnected.com/the-10-minute-read-to-understanding-devops-tools-bc4ac807a25d" target="_blank" rel="noopener"
>https://levelup.gitconnected.com/the-10-minute-read-to-understanding-devops-tools-bc4ac807a25d&lt;/a>&lt;/p>
&lt;p>在我们开始谈论DevOps工具和类别之前，让我们退一步讨论几个基本的（但往往是超载的）术语以及它们的含义。&lt;/p>
&lt;p>&lt;strong>计算机/服务器&lt;/strong> - &lt;strong>Computer/Server&lt;/strong>： 具有中央处理器（CPU）、内存（RAM）、本地存储（磁盘）并运行操作系统的物理设备。&lt;/p>
&lt;p>&lt;strong>虚拟机&lt;/strong> - &lt;strong>Virtual Machine&lt;/strong>：在主机上运行的计算机系统的模拟器（虚拟机管理程序）；vm 通常可以在CPU、内存和磁盘使用方面与其他操作系统隔离。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/img/cos/2021-04-02-0-cuHFPvnmr141Dfcc.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;strong>容器&lt;/strong>&amp;ndash;&lt;strong>Containers&lt;/strong>：打包一个软件及其所有依赖，使其能够在任何基础设施上统一、一致地运行。Docker容器是最流行的。它们允许你打包一堆东西（你的软件、配置和其他软件），以便于部署和传输。你可以把容器看作是虚拟化的下一代进化（继虚拟机之后）。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/img/cos/2021-04-02-0-hWRNCynYRFw2KCxn.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;strong>网络设备&lt;/strong> - &lt;strong>Network Device&lt;/strong>：在设备之间路由网络流量的硬件。例如路由器、负载平衡器和防火墙。&lt;/p>
&lt;p>&lt;strong>软件&lt;/strong> - &lt;strong>Software&lt;/strong>：编码并在操作系统上运行的代码。&lt;/p>
&lt;p>&lt;strong>DevOps&lt;/strong> - 传统上有 &amp;ldquo;开发&amp;rdquo;（你来构建它），还有 &amp;ldquo;运维&amp;rdquo;（我们将运行它），他们两者之间的一切都受制于作坊式的工作方式。从2010年左右开始，到2018年左右DevOps 已经发展为几乎无处不在的现象，DevOps的理念是：&amp;ldquo;一套实践，目的是在保证高质量的前提下，缩短从提交系统变更到变更投入正常生产环境之间的时间&amp;rdquo;。&lt;/p>
&lt;p>当你在考虑构建和运行一个非同寻常的系统时，其实还有很多不得不做的事情。以下是需要考虑到的传统的事项清单。&lt;/p>
&lt;ol>
&lt;li>获取计算机/服务器硬件 （Obtaining the computer/server hardware）&lt;/li>
&lt;li>配置计算机/服务器硬件（操作系统、网络布线等）（Configuring the computer/server hardware (operating systems, network wiring, etc.)）&lt;/li>
&lt;li>监控计算机/服务器硬件（Monitoring the computer/server hardware）&lt;/li>
&lt;li>获取网络设备（负载均衡器、防火墙、路由器等）（Obtaining the network devices (load balancers, firewalls, routers, etc.)）&lt;/li>
&lt;li>配置网络设备（Configuring the network devices）&lt;/li>
&lt;li>监控网络设备（Monitoring the network devices）&lt;/li>
&lt;li>编写软件（Constructing the software）&lt;/li>
&lt;li>构建软件（Building the software）&lt;/li>
&lt;li>测试软件（Testing the software）&lt;/li>
&lt;li>软件打包（Packaging the software）&lt;/li>
&lt;li>部署/发布软件（Deploying/releasing the software）&lt;/li>
&lt;li>监测软件（Monitoring the software）&lt;/li>
&lt;/ol>
&lt;p>在DevOps之前，我们曾经有四个不同的团队在做这项工作。&lt;/p>
&lt;ul>
&lt;li>Developer 开发人员 — 他们会做 #7, #8 ，有时候包括 #10&lt;/li>
&lt;li>QA 测试人员— 他们会做 #9 ，有时候包括 #11&lt;/li>
&lt;li>System Administrator 系统管理员 — 他们会做 #1, #2, #3, #12&lt;/li>
&lt;li>Network Administrator 网络管理员 — 他们会做 #4, #5, #6&lt;/li>
&lt;/ul>
&lt;p>对于硬件、网络设备和软件的配置，每个团队很可能会使用自己的一套脚本和工具，而且在很多情况下，会通过手工操作来实现 &amp;ldquo;软件发布&amp;rdquo;。&lt;/p>
&lt;p>随着DevOps的出现，对我来说，关键的想法是打破这些部门墙，让每个人都成为 &amp;ldquo;一个 &amp;quot; 团队的一部分，为所有事物的配置、部署和管理方式带来一致性。&lt;/p>
&lt;p>&lt;strong>云&lt;/strong>&amp;ndash;&lt;strong>Cloud&lt;/strong>：定义信息技术史上最流行的名词是很难的，但我喜欢那件T恤，上面写着 &amp;ldquo;没有云，只是别人的电脑&amp;rdquo;。最初，当云服务开始的时候，它们真的只是别人的电脑（或者运行在电脑上的虚拟机），或者存储。随着时间的推移，它们已经演变成到了现在的状态，包含很多很多的增值服务。硬件大部分已经被抽象掉了，现在大多数云服务中，你不能购买它们的硬件设备，但你可以购买这些硬件设备所提供的各种云服务。&lt;/p>
&lt;p>&lt;strong>基础架构即代码&lt;/strong>(&lt;strong>IAC&lt;/strong>)&amp;ndash;：一种新的能力或概念，它允许我们通过定义或配置文件来完整的定义数据中心中所有项目的设置，包括虚拟机、容器和网络设备。这个概念是我可以创建一些配置和一些脚本，然后使用我们即将讨论的一个工具来运行它们，它们会自动为我们按需配制出数据中心的所有服务。CI/CD是IAC的前身，多年来我们一直致力于自动化我们的构建/测试/集成/部署周期，在我们的云基础设施上做这个工作是一个自然的延伸。这带来了成本的降低，更快的上市时间，以及更小的风险（人为错误）。&lt;/p>
&lt;p>随着IAC的出现，许多传统的开发工具现在可以用于管理基础设施。像软件仓库、构建工具、CI/CD、代码分析器和测试工具等类别的工具（如下所列），传统上是由软件开发人员使用的，现在可以被DevOps工程师用来构建和维护基础设施。&lt;/p>
&lt;blockquote>
&lt;p>AGAIN: &amp;ldquo;随着DevOps的出现，对我来说，关键的理念是&amp;hellip;&amp;hellip;让每个人都成为&amp;rsquo;一个&amp;rsquo;团队的一部分，为所有事物的配置、部署和管理方式带来一致性。&amp;rdquo;&lt;/p>&lt;/blockquote>
&lt;p>因此，现在我们已经定义了以上基础术语/概念，让我回到试图对DevOps工具进行分类的任务，以使我们更容易确定什么工具是用于什么目的的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>软件仓库&lt;/strong> &amp;ndash; 管理软件版本的工具&amp;ndash;目前使用最广泛的是Git。&lt;/li>
&lt;li>&lt;strong>构建工具&lt;/strong>&amp;ndash;有些软件在打包或使用前需要编译，传统的构建工具包括Make、Ant、Maven和MSBuild。&lt;/li>
&lt;li>&lt;strong>持续集成工具&lt;/strong>&amp;ndash;在配置好以后，每次将代码提交到存储库中时，它都会对软件进行构建、部署和测试。这通常可以提高软件质量和上市时间。这个市场上最流行的工具是 Jenkins、Travis、TeamCity和Bamboo。&lt;/li>
&lt;li>&lt;strong>代码分析/审查工具&lt;/strong>&amp;ndash;这些工具可以查找代码中的错误，检查代码格式和质量，以及测试覆盖率。这些工具因编程语言而异。SonarQube是这个领域的一个流行工具，还有其他各种 &amp;ldquo;轻量的 &amp;ldquo;工具。&lt;/li>
&lt;li>&lt;strong>配置管理&lt;/strong>&amp;ndash;配置管理工具和数据库通常存储所有关于你的硬件和软件项目的信息，以及提供一个脚本和/或模板系统，用于自动化常见任务。在这个领域似乎有很多玩家。传统的玩家是Chef、Puppet和Salt Stack。&lt;/li>
&lt;li>&lt;strong>部署工具&lt;/strong>&amp;ndash;这些工具有助于软件的部署。许多CI工具也是CD（持续部署）工具，它们协助软件的部署。传统上在Ruby语言中，Capistrano工具被广泛使用；在Java语言中，Maven被很多人使用。所有的编排工具也都支持某种形式的部署。&lt;/li>
&lt;li>&lt;strong>编排工具&lt;/strong>&amp;ndash;这些工具配置、调度和管理计算机系统和软件。它们通常将 &amp;ldquo;自动化 &amp;ldquo;和 &amp;ldquo;工作流 &amp;ldquo;作为其服务的一部分。Kubernetes是一个非常流行的编排工具，它专注于容器。Terraform是一个非常流行的编排工具，它的关注点更广，包括云编排。另外，每个云提供商都有自己的一套工具（CloudFormation、GCP Deployment Manager, 和ARM）。&lt;/li>
&lt;li>&lt;strong>监控工具&lt;/strong> - 这些工具允许监控硬件和软件。通常，它们包括监控代理程序，用于监视进程和日志文件，以确保系统的健康。Nagios是一种流行的监控工具。&lt;/li>
&lt;li>&lt;strong>测试工具&lt;/strong> - 测试工具用于管理测试，以及测试自动化，包括性能和负载测试等。&lt;/li>
&lt;/ul>
&lt;p>当然，和其他任何一套产品一样，类别也不一定完全清晰。许多工具都是跨类别的，并提供两个或多个类别的功能。下面是我试图展示大多数非常流行的工具，并可视化它们在这些类别中的位置。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/img/cos/2021-04-02-1-wTp-r9QJvF-DXGZDZUHmbA.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>正如你所看到的，有几个玩家，如Ansible、Terraform和云工具(AWS、GCP和Azure)，正试图通过他们的产品覆盖部署、配置管理和编排类别。老牌工具集Puppet、Chef和Salt Stack专注于配置管理和自动化，但已经扩展到编排和部署的。还有像GitLab和Azure DevOps这样的工具，几乎试图跨越DevOps的所有类别。&lt;/p>
&lt;p>我希望这个概述能帮助你了解DevOps的基础知识，可用工具的类别，以及目前市场上的各种产品如何在这些类别中的一个或多个类别中提供帮助。在Solution Street，多年来我们已经使用了许多这样的工具，对我们来说，没有一个单一的 &amp;ldquo;一招鲜 &amp;ldquo;的工具能胜任所有情况下使用。使用什么是基于所使用的技术，在哪里托管（以及未来可能在哪里托管），以及团队的人才和构成。&lt;/p>
&lt;blockquote>
&lt;p>教练观点：敏捷教练不能回避DevOps 工具链的话题，中低层管理人员更应该在宏观上深刻理解 SLDC 所有环节的技术概要和工具需求，需要具备基础的概念知识，具备和工程师讨论所必备的语言。工程师们更要有工具链整体优化的意识，而不仅仅是精通某个环节，或局限在与自己的上下游工具上，工作在这个系统中的所有人需要有全局协作和优化的意识，优化价值流的流量、流速，关注价值的产生。警惕&amp;mdash;-整个工具链的自动化程度越高，不一定工作效率越高，加班越少，公司盈利越多。它们其实是相互作用的。&lt;/p>&lt;/blockquote></description></item><item><title>在 Github 上搭建基于 Hugo 的免费个人博客</title><link>https://martinliu.cn/blog/github-hugo-blog/</link><pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate><guid>https://martinliu.cn/blog/github-hugo-blog/</guid><description>&lt;img src="https://martinliu.cn/img/2019/03/pic03.jpg" alt="Featured image of post 在 Github 上搭建基于 Hugo 的免费个人博客" />&lt;p>最近更新了新的博客样式，再次搬迁回到了 GitHub 平台，并使用了 Github Action 的自动化 CI/CD 发布功能。这个是一个任何人都可以拥有的方案，现在用最简洁的语言分享给大家。&lt;/p>
&lt;p>选择将博客搭建在 Github 上的原因包括：&lt;/p>
&lt;ul>
&lt;li>Github Pages 是一个免费使用的功能，在不强求网站访问速度，考虑持久性的情况下，Github Pages 不失为一根优秀的羊毛。&lt;/li>
&lt;li>用 master 分支管理 hugo 站点的所有代码和文件（markdown、网站模板和图片），用 gh-pages 分支存放 Hugo 编译后的网站发布文件&lt;/li>
&lt;li>Github Actions 功能实现了自动化的编译和部署功能，使用它所提供的工作流将 master 分支中的更新编译后发布到 gh-pages 分支中&lt;/li>
&lt;/ul>
&lt;p>而 Hugo 是一款比较流行的静态网站管理软件，可以在各种操作系统轻松的安装本地的博客环境，在本地的操作系统上实现博客的预览和测试。Hugo 的社区提供了大量的免费网站模板，不同类型的模板可以满足各种网站需求。&lt;/p>
&lt;h2 id="选择-hugo-博客主题">选择 Hugo 博客主题
&lt;/h2>&lt;p>在 &lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>https://themes.gohugo.io/&lt;/a> 可以搜索到大量的免费网站模板。我这次选择了名为 “HUGO FUTURE IMPERFECT SLIM” 的模板。&lt;/p>
&lt;p>这是一个功能非常丰富的模板：&lt;/p>
&lt;ul>
&lt;li>界面简洁，兼具丰富的格式，博客文章有头图&lt;/li>
&lt;li>带有侧栏&lt;/li>
&lt;li>带有 ‘about’ ‘categories’ ‘contact’ 等独立页面格式，无头图&lt;/li>
&lt;li>具有多语言支持和菜单选择&lt;/li>
&lt;li>带有搜索页面&lt;/li>
&lt;li>带有讨论功能&lt;/li>
&lt;/ul>
&lt;p>对我而言这些都是很快就都可以用到的功能。&lt;/p>
&lt;p>Hugo 博客本地安装和配置新手指南，参考这两篇文章。&lt;/p>
&lt;ol>
&lt;li>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/102131163" target="_blank" rel="noopener"
>零基础使用 Hugo 和 GitHub 搭建个人博客&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://sb.sb/blog/migrate-to-hugo/" target="_blank" rel="noopener"
>使用 Hugo 生成静态博客教程&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="github-pages-新手指南">GitHub Pages 新手指南
&lt;/h2>&lt;p>在 &lt;a class="link" href="https://pages.github.com/" target="_blank" rel="noopener"
>https://pages.github.com/&lt;/a> 提供了视频和文字版本的新手指南教程。为了方便新手理解，下面就使用‘user or organization site’这个最常用的选项做简要说明：&lt;/p>
&lt;ol>
&lt;li>创建与自己的 &lt;strong>Github 用户/组织&lt;/strong> 同名前缀的公开代码仓库，例如：zhangsan/zhangsan.github.io&lt;/li>
&lt;li>选择在命令行里（前提是安装配置好了 Git，否则使用图形化界面 GitHub Desktop 工具）&lt;/li>
&lt;li>克隆第一步创建的那个代码库到本地电脑的目录中。&lt;/li>
&lt;li>创建只包含 ‘Hello World’ 为内容的主页测试文件。&lt;/li>
&lt;li>推送本地的更新到 Github 服务器端&lt;/li>
&lt;li>在本地的浏览器中查看测试网页 &lt;a class="link" href="http://zhagnsan.github.io/" target="_blank" rel="noopener"
>http://zhagnsan.github.io/&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>GitHub Pages 的新手指南已经包含在了上一节推荐的两篇文章中。&lt;/p>
&lt;h2 id="使用-github-actions-自动化发布博客更新">使用 Github Actions 自动化发布博客更新
&lt;/h2>&lt;p>本地的测试环境是非常重要的，可以帮我们快速的掌握 Hugo 的基本使用方式，测试和选择网站模板。在模板确定了以后，就进入了日常的内容更新过程中，平常内容更新的工作都是在 master 分支中进行。并不会在本地操作 gh-pages 分支，这个分支里只会存放的是 Hugo 编译之后结果内容，即 public 目录中的内容。&lt;/p>
&lt;p>你可以在代码库的 Actions 标签页面中，创建一个默认的演示工作流文件，在本地做一个测试更新，用 push 动作测试触发和执行它。从无到有的创建新工作流文件的过程在这里不讲解。&lt;/p>
&lt;p>在本使用 Github Actions 的功能的主要目的如下：&lt;/p>
&lt;ol>
&lt;li>通过 master 分支的 push 事件，触发自动化工作流，即 CI/CD 工作流，这里是持续部署的过程。&lt;/li>
&lt;li>将 master 分支的内容签出，使用新配置的 Hugo 软件构建全站的所有内容&lt;/li>
&lt;li>将构建后的结果发布更新到 gh-pages 分支中。&lt;/li>
&lt;/ol>
&lt;p>下面是我所使用的工作流代码和注释。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># 将 Hubo 博客构建后部署到 Github Pages
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name: Deploy github-pages
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 在 master 主干分支的任何 push 事件都会触发本 DevOps 工作流水线
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">on:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> push:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> branches: [ master ]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 以下是本串行执行工作流的所有组成部分
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jobs:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 这里只定义了一个名为 &amp;#34;deploy&amp;#34; 的多步骤作业
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> build-deploy-hugo-blog:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 将后续的所有工作步骤都运行在最新版的 ubuntu 操作系统上
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> runs-on: ubuntu-latest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 本构建和部署作业的所有步骤定义如下
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> steps:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # Step 1 - Checks-out 你的代码库到 $GITHUB_WORKSPACE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Checkout blog code repo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uses: actions/checkout@v2 # 这是 Github 官方提供的一个动作模块
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> with:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> submodules: true # 同步更新所使用的 Hugo 模板
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> fetch-depth: 0 # 更新到该模板最新的版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # Step 2 - 配置最新版本的 Hugo 环境
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Setup Hugo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uses: peaceiris/actions-hugo@v2 # 这是 Github Actions 市场中的一个动作模块
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> with:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> hugo-version: &amp;#39;latest&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # Step 3 - 清理代码库中 public 目录中的内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Clean public directory
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> run: rm -rf public # 彻底删除这个目录
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # Step 4 - 用最新版本的 Hugo 构建个人博客站点
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Build blog site
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> run: hugo --minify
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # Step 5 - 创建用于私有域名所需要的 CNAME 文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Create CNAME file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> run: echo &amp;#39;martinliu.cn&amp;#39; &amp;gt; public/CNAME
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # Step 6 - 将构建好的博客站点推送发布到 gh-pages 分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - name: Deploy blog to Github-pages
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> uses: peaceiris/actions-gh-pages@v3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> with:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> github_token: ${{ secrets.DEPLOY_KEY }}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> publish_dir: ./public
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="后续事项">后续事项
&lt;/h2>&lt;ol>
&lt;li>解决旧文章头图空白的问题&lt;/li>
&lt;li>增加文章评论功能&lt;/li>
&lt;li>增加 CDN 功能&lt;/li>
&lt;/ol></description></item><item><title>Skaffold 让 K8s 开发者更加酸爽</title><link>https://martinliu.cn/blog/skaffold-make-local-k8s-dev-easy/</link><pubDate>Wed, 15 Jul 2020 00:09:53 +0800</pubDate><guid>https://martinliu.cn/blog/skaffold-make-local-k8s-dev-easy/</guid><description>&lt;img src="https://martinliu.cn/images/abstract-1.jpg" alt="Featured image of post Skaffold 让 K8s 开发者更加酸爽" />&lt;p>&lt;img src="https://martinliu.cn/images/skaffold.png"
loading="lazy"
>&lt;/p>
&lt;p>今天介绍一个本地 Kubernetes 开发的利器 Skaffold。
这是我偶然间发现的一个工具，询问了一下周围的人，居然还没有人用过。测试之后，确实有一种不吐不快的感觉。&lt;/p>
&lt;h2 id="简介">简介
&lt;/h2>&lt;p>&lt;img src="https://martinliu.cn/images/intro.gif"
loading="lazy"
>&lt;/p>
&lt;p>Skaffold Google 开发的一个开源项目。是一个非常轻量的命令行工具，就是一个可执行文件。它的主页上是这样的介绍它的。&lt;/p>
&lt;ul>
&lt;li>轻量：Skaffold只是一个客户端工具。由于集群上不需要任何的相关组件，您的集群没有任何开销或维护负担。&lt;/li>
&lt;li>运行在任何地方：Skaffold是与世界分享你的项目的最简单的方法：&amp;ldquo;git clone&amp;rdquo;，然后 &amp;ldquo;skaffold run&amp;rdquo;。此外，你还可以使用配置文件、本地用户配置、环境变量和标志来轻松地集成不同环境的差异。&lt;/li>
&lt;li>功能丰富：Skaffold拥有许多Kubernetes原生开发的基本功能，包括基于策略的打镜像标签、资源端口转发和日志、文件同步等。&lt;/li>
&lt;li>优化你的开发：Skaffold使内部循环紧密，高度优化，让您在开发的同时得到即时反馈。&lt;/li>
&lt;/ul>
&lt;h2 id="客户评价">客户评价
&lt;/h2>&lt;p>&lt;img src="https://martinliu.cn/images/forgerock.png"
loading="lazy"
>&lt;/p>
&lt;p>&amp;ldquo;我们的客户很喜欢[Kubernetes]，但一直给我们反馈说在Kubernetes上开发很麻烦。Skaffold一针见血地解决了这个问题。以前需要几分钟才能部署的docker镜像或配置的更改，现在只需要几秒钟。Skaffold的插件架构使我们能够部署到Helm或Kustomize，并使用各种docker构建插件，如Kaniko。Skaffold用一个精简的工具取代了我们定制的实用程序和脚本集合，并且易于使用。&amp;rdquo;
Warren Strange，ForgeRock的工程总监。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/images/quora.png"
loading="lazy"
>&lt;/p>
&lt;p>&amp;ldquo;当我们评估我们可以使用Kubernetes的工作流程时，Skaffold脱颖而出，成为我们在开发和部署中都想要的工具。它为我们提供了一个跨应用程序的通用入口点，我们也可以为CI/CD重用。现在，我们所有的Kubernetes应用的CI/CD管道在构建和部署时都使用Skaffold。&amp;rdquo;
Taylor Barrella，Quora的软件工程师&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/images/tng.png"
loading="lazy"
>&lt;/p>
&lt;p>&amp;ldquo;Skaffold是一个了不起的工具，它为我们简化了开发和交付。Skaffold通过覆盖两个维度，击中了我们的甜蜜点。第一，从本地开发、集成测试到交付的整个开发周期。第二，Skaffold让我们能够在Linux、OSX和Windows上独立开发，不需要特定的平台逻辑。&amp;rdquo;
Martin Höfling，TNG技术咨询有限公司首席顾问&lt;/p>
&lt;h2 id="推荐首次测试流程">推荐首次测试流程
&lt;/h2>&lt;p>前置条件，你的开发用工作电脑上已经安装了它需要调用的 kubectl 和 docker 命令，kubectl 需要有至少一个可用的配置，这个配置可以指向任一一个你有权限部署的 Kubernetes 集群。&lt;/p>
&lt;p>我在 macOS 上，直接运行 &lt;code>‌brew install skaffold&lt;/code> 即可，其它系统参考：&lt;a class="link" href="https://skaffold.dev/docs/install/" target="_blank" rel="noopener"
>https://skaffold.dev/docs/install/&lt;/a>&lt;/p>
&lt;p>克隆 Skaffold 的代码库到本地，获取必要的测试应用代码。&lt;/p>
&lt;p>&lt;code>‌git clone https://github.com/GoogleContainerTools/skaffold&lt;/code>&lt;/p>
&lt;p>进入代码库中的‘hello world’示例应用。&lt;/p>
&lt;p>执行：&lt;code>‌cd skaffold/examples/getting-started&lt;/code>&lt;/p>
&lt;p>执行 &lt;code>‌skaffold dev&lt;/code> ，你会看到 Skaffold 进入了这个项目的构建和运行的状态，执行结果是持续的输出 ”[getting-started] Hello world!“&lt;/p>
&lt;p>现在 Skaffold 就进入了 /getting-started 的监视状态。观察任何代码文件的修改存盘动作，每次代码的变更会触发 Skaffold 流水线的执行，skaffold.yaml 文件中描述了本地流水线中的相关动作：&lt;/p>
&lt;ul>
&lt;li>使用 Dockerfile 从源头构建Docker镜像。&lt;/li>
&lt;li>用Docker镜像的内容的sha256哈希值来打上标签。&lt;/li>
&lt;li>更新 Kubernetes manifest k8s-pod.yaml，以使用上一步构建的镜像。&lt;/li>
&lt;li>使用 kubectl apply -f 部署 Kubernetes manifest。&lt;/li>
&lt;li>从已部署的应用程序取回日志在本地控制台显示。&lt;/li>
&lt;/ul>
&lt;p>现在用代码编辑器打开这个项目唯一的程序文件 main.go ，修改其中的 Hello World 为其它你想到的词，保存后，观察构建的过程。&lt;/p>
&lt;h2 id="推荐微服务测试">推荐微服务测试
&lt;/h2>&lt;p>参考以下视频，测试 Skaffold 代码库中的 microservice 项目。&lt;/p>
&lt;h2 id="skaffold-流水线阶段">Skaffold 流水线阶段
&lt;/h2>&lt;p>Skaffold 主要会用到五个阶段。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/images/workflow.png"
loading="lazy"
>&lt;/p>
&lt;p>其所有阶段如下：&lt;/p>
&lt;ul>
&lt;li>Init ： generate a starting point for Skaffold configuration&lt;/li>
&lt;li>Build ：build images with different builders&lt;/li>
&lt;li>Tag ： tag images based on different policies&lt;/li>
&lt;li>Test ：test images with structure tests&lt;/li>
&lt;li>Deploy ：deploy with kubectl, kustomize or helm&lt;/li>
&lt;li>File Sync ： sync changed files directly to containers&lt;/li>
&lt;li>Log ： Tailing tail logs from workloads&lt;/li>
&lt;li>Port Forwarding ：forward ports from services and arbitrary resources to localhost&lt;/li>
&lt;li>Cleanup ： cleanup manifests and images&lt;/li>
&lt;/ul>
&lt;p>当你启动Skaffold时，它就会收集你项目中的源代码，并使用你所选择的工具构建工件；工件一旦成功构建，就会根据你的需要进行标记，并推送到你指定的仓库中。在工作流程的最后，Skaffold还帮助你将工件部署到你的Kubernetes集群中，同样使用你喜欢的工具。&lt;/p>
&lt;p>Skaffold允许你跳过各个阶段。例如，如果你在本地使用Minikube运行Kubernetes，Skaffold不会将工件推送到远程仓库。&lt;/p>
&lt;p>每个阶段的详情见：&lt;a class="link" href="https://skaffold.dev/docs/pipeline-stages/" target="_blank" rel="noopener"
>https://skaffold.dev/docs/pipeline-stages/&lt;/a>&lt;/p>
&lt;h2 id="架构设计">架构设计
&lt;/h2>&lt;p>Skaffold 秉承着插件化的设计思想。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/images/architecture.png"
loading="lazy"
>&lt;/p>
&lt;p>以上架构内置了对下来工具的支持：&lt;/p>
&lt;ul>
&lt;li>Build
&lt;ul>
&lt;li>Dockerfile locally, in-cluster with kaniko or on cloud using Google Cloud Build&lt;/li>
&lt;li>Jib Maven and Jib Gradle locally or on cloud using Google Cloud Build&lt;/li>
&lt;li>Bazel locally&lt;/li>
&lt;li>Cloud Native Buildpacks locally or on cloud using Google Cloud Build&lt;/li>
&lt;li>Custom script locally or in-cluster&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Test
&lt;ul>
&lt;li>container-structure-test&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Tag&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Git tagger&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>Sha256 tagger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Env Template tagger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DateTime tagger&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Deploy&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Kubernetes Command-Line Interface (kubectl)&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Helm&lt;/li>
&lt;li>kustomize&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>Skaffold 确实让基于 Kubernetes 的开发者的本地工作环境更加优化和整洁了。希望本文对你的工作有所帮助。&lt;/p></description></item><item><title>基础架构的持续集成和应用部署</title><link>https://martinliu.cn/blog/devops-infrastructure-ci-app-deployment/</link><pubDate>Sat, 17 Mar 2018 10:50:57 +0800</pubDate><guid>https://martinliu.cn/blog/devops-infrastructure-ci-app-deployment/</guid><description>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/coding-snippet.jpg" alt="Featured image of post 基础架构的持续集成和应用部署" />&lt;p>持续集成通常是针对应用而言的，可是基础架构的持续集成应该怎么做？基础架构的持续集成应该属于持续交付/部署的基础。贯串本文的一个问题，或者在阅读本文时，您应该不断地问自己这个问题：我们的应用部署流程是怎样的？&lt;/p>
&lt;p>在回答这个问题之前，我们先来回顾一下，目前几乎所有人正在使用的手工环境和资源交付流程。在源码被编译打包了以后，安装包文件被上传保存到了内部的某个文件服务器上。Ops团队的某个组/人被分配到工单，根据工单描述的需求，它在测试或者生产环境中开始工作：&lt;/p>
&lt;ul>
&lt;li>用图形界面进行虚拟机模板的手工克隆工作，或者由于没有相应的权限或者自助服务，不得不给虚拟化管理员发任务单，然后等待回复。&lt;/li>
&lt;li>获取用户名和密码手工登录服务器，有些企业还要是等待领导的审批，才能得到密码信封和所需要的访问密码。&lt;/li>
&lt;li>根据工单（变更单）里的描述和自己的经验对虚拟机的操作系统进行配置，在这个过程中，Ops往往可能还需和需求方进行不止一次的沟通，确认相关参数。&lt;/li>
&lt;li>手工的下载应用安装包，然后分别手工上传到目标的服务器，凭经验和工单信息部署应用，然后测试部署结果，可能是看下页面有没有正常显示，或者服务起没起.&lt;/li>
&lt;li>手工测试和确认这些虚拟机的服务和状态，凭经验觉得OK了以后，回复工单，关闭工单。&lt;/li>
&lt;/ul>
&lt;p>以上的工作场景，可能是Ops人员很常规的一天，或者是几天内的工作，当然在这个过程中，他们还需要参与一些救火行动；他们在这个过程中也可能会有疑问，也可能会对此工作结果不确定；但是，日常的工作经验告诉他，差不多了，关闭任务单要紧，还有好多项目催活呢！就这样，配置并不精确的虚拟机环境就交给了下游的需求方。&lt;/p>
&lt;p>以上工作过程的问题如下：&lt;/p>
&lt;ol>
&lt;li>工作周期长，速度慢。实际上工作周期拖延的越久，工作结果的质量就越差，而并不是我们想想中的慢工出细活。&lt;/li>
&lt;li>所有步骤都是纯手工操作，不仅费事费力，而且出错几率高，也几乎不可能无痛的回退。可能有人会说了，我们不需要那么快，我们也不是互联网公司；可是从精益思想的角度看，以上这些工作都属于对业务价值的交付贡献为零的工作；你可能是由于公司给你发着工资，才错误的感觉到，这项工作活动应该有它的价值。&lt;/li>
&lt;li>上游传递来的信息可能不全面，不准确，因此Ops很有可能造成错误配置，因此会返工。&lt;/li>
&lt;li>传递给下游的虚拟机很可能会在后续的部署过程中，由于应用需求的变化，而需要下游的人员对其重新配置，产生重复的劳动。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>手工部署的时间和代价 = 应的数量 X 应用版本数量 X 环境数量&lt;/p>&lt;/blockquote>
&lt;p>对以上工作系统进行优化的原则：如果某一项活动的重复频率越高，那么对它进行优化，所产生的回报也会越明显；这里还要参考限制理论，优化的顺序要正确。&lt;/p>
&lt;p>我们从这个角度出发，就可以来设定基础架构持续集成和应用部署流程的改进目标了：&lt;/p>
&lt;ul>
&lt;li>减少总体人工工作时间和代价&lt;/li>
&lt;li>提高交付的速度、可靠性和频率&lt;/li>
&lt;li>能进行应用部署，能进行数据库Schema的更新&lt;/li>
&lt;li>能够实现部署流程的自服务，让任何需要部署应用的人能一键式部署任何版本&lt;/li>
&lt;/ul>
&lt;p>到了这里我们就必须将上述手工劳动，变为自动化的过程。因此，基础架构即代码IaC （Infrastructure as code）和相关的配置管理工具就会用到。&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/delivery-Pipeline.png"
loading="lazy"
alt="delivery-Pipeline"
>&lt;/p>
&lt;p>上图是一个典型的持续交付流水线模型，在此我们对它的关注点如下：&lt;/p>
&lt;ul>
&lt;li>代码的变更被Jenkins自动化的构建（CI是基础），打包后的安装包被存储在Artifactory里，Artifactory里面还可以存储应用包的其它相关元数据，如测试结果，能否可以用于下一步部署的标签等等。&lt;/li>
&lt;li>Jenkins自动化的搭建所需要的环境，调用虚拟化或者公有云资源池的API，制备虚拟机资源，然后调用Chef完成对虚拟机的配置，完成应用包部署所需要的所有层次的配置。&lt;/li>
&lt;li>环境配置完成后，应用正常运行了，在相关的测试工具对部署后的环境做验收测试，Chef具有支持测试驱动的相关工具。&lt;/li>
&lt;/ul>
&lt;h2 id="基础架构的持续集成">基础架构的持续集成
&lt;/h2>&lt;p>为了实现完整的基础架构持续集成流程，以上持续交付流水线必须具备的能力和概念包括：分层的系统管理、基础架构即代码IaC、配置管理、Chef工具等。下面详细对它们进行描述。&lt;/p>
&lt;h3 id="分层的系统管理">分层的系统管理
&lt;/h3>&lt;p>系统管理的层次涉及到OS相关的三个层次。下面自下而上地简单描述一下。&lt;/p>
&lt;ol>
&lt;li>制备管理：涉及到虚拟化层，这一层是资源表达层，目前所有主流的虚拟化都支持标准的Rest API，包括VMWare、EC2和Nuanix等。大多数主流配置管理工具都具备用于虚拟机生命周期管理（从生成、到开机、到删除等）的API功能，能按需的获得任何数量、规模、网络和操作系统类型的部署环境。&lt;/li>
&lt;li>配置管理：在任何类型的操作系统里自动化的安装和配置软件包，将所有配置参数配置好以后，持续保持这些配置点的状态。对于简单应用，来说按配置参数启动服务即任务完成。&lt;/li>
&lt;li>应用编排管理：对于复杂的分布式系统，由于各个自服务之间存在着依赖关系，所有自服务之前需要互通一些配置参数才能实现，应用程序整体的正常运行，配置应用服务器的odbc数据库连接，配置web前端的ldap认证服务器等等。目前微服务所涉及的服务发现和路由，是应用编排必备的配套设施。&lt;/li>
&lt;/ol>
&lt;p>不同的DevOps配置管理工具也都力求能覆盖以上三个层次，但是他们所追求的方向，或者想解决的主要问题并不相同。因此各个工具之间功能上有重叠。&lt;/p>
&lt;p>因此在运用这些工具的时候，不仅要追求其卓越的功能，还要能意识到，并有意的在不同层面上做取舍。&lt;/p>
&lt;h3 id="基础架构即代码">基础架构即代码
&lt;/h3>&lt;p>IaC这个概念最早是被Chef这类工具提出并实现，它的基本想法就是让Ops人员象开发人员一样的，工作在基础架构的代码上，而不是面对着数十个图形和文字终端界面。使用类似于开发应用程序的方式，开发和管理基础架构环境，因此基础架构能通过API访问和操控是基础，目前所有主流的虚拟化/云计算平台都具备很好的API接口；可惜的是在传统的企业环境中，这些资源池的API功能几乎没有被用到。&lt;/p>
&lt;p>像开发应用代码一样的管理IT基础架构，基础架构的开发和管理也需要遵循与应用开发类似的原则，这些原则包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一切从源代码开始&lt;/strong>:并对其进行严格的版本管理，要对基础架构变更，就需要对相应的代码进行变更和测试，最后发布这些代码。从而力求做到服务器的无人登录运维。&lt;/li>
&lt;li>&lt;strong>模块化设计&lt;/strong>:不同应用底层所使用的基础架构有着大量的相似之处，模块化的设计不仅意味着标准化，也意味着更少的重复代码。我所用过的Terraform、Chef和Puppet这三种工具，都具有高度的模块化特性。&lt;/li>
&lt;li>&lt;strong>抽象能力&lt;/strong>：能够使用不同的模块和参数对任何特征的应用进行建模，用IaC代码进行表达，基础架构的代码开发也就是借助这种抽象能力，将所有管理对象（配置管理项）具体化地描述为应用服务模型。编写出来的基础架构代码，不仅包含了所有对应用配置描述性的语义，而且还是能够被执行的代码，在IaC代码执行之后，你就得到了所期望的虚拟机、应用配置和应用服务。&lt;/li>
&lt;li>&lt;strong>可测试性&lt;/strong>：这是一个经常忽略的能力，而在了解之后，你会发现IaC也是编程语言，就是对基础架构进行高级的编程，而且IaC代码本身和它的运行结果都是可以测试的。在执行前对其语义语法测试，在运行以后对其运行结果测试。Chef在这方面表现的尤为突出。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/chef-logo.png"
loading="lazy"
alt="Chef"
>&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/LogoTerraform.png"
loading="lazy"
alt="Terraform"
>&lt;/p>
&lt;h3 id="配置管理">配置管理
&lt;/h3>&lt;p>我可能是最早的一批进行ITIL配置管理实践，CMDB建设的这批人；我以前和甲方客户有着大量的关于配置管理和CMDB的对话，所经历过的项目也非常煎熬。而在DevOps场景下，感觉以前的经历也是很有意思的，只是我现在说到的CI，在没有特指的情况下，是持续集成的概念，还不是配置项了。&lt;/p>
&lt;blockquote>
&lt;p>Process for establishing and maintaining consistency of a product’s performance, functional and physical attributes with its requirements, design and operational
information throughout its life。&lt;/p>&lt;/blockquote>
&lt;p>以上是配置管理在维基百科里的定义，它所表达的含义还是值得借鉴的；而如今很多人对DevOps的认识，还有人是建立在DevOps配置管理相关的工具上的。为了纠正这个错误观点，我们经常说：“天文学并不只是关于望远镜的。”&lt;/p>
&lt;p>配置管理工具中有很多是基于主机（OS）的管理工具，包括：CFEngine、Puppet、Chef、Salt和Ansible等。它们都具有基础架构即代码的相关原则和特征。都能实现：定义服务器的目标期望状态的能力，在每一次执行周期里，它们都进行状态检查，汇报当前状态和目标状态的偏差，在必要的时候也可以自动的执行必要的状态修复操作。&lt;/p>
&lt;p>Chef这种配置管理工具，使用了Ruby风格的DSL语言，使用者只需要用Chef代码表达”What“即可，而不需要明白”How“；”What“既是对目标配置状态的描述，使用者只需要将需求转换为Chef代码，然后用Chef客户端工具运行它即可。Chef的代码清晰，描述能力强大。在编码的时候遵循DSL规则，如果有必要的话也可以调用Ruby。&lt;/p>
&lt;p>Chef是客户端服务器的架构，安装了&lt;strong>Chef-client&lt;/strong>程序的节点可以注册到一个&lt;strong>Chef管理服务器&lt;/strong>里。&lt;/p>
&lt;p>Chef的开发人员（IaC编码者），在安装了用于和Chef服务器交互的名为&lt;strong>knife&lt;/strong>的工具，称之为&lt;strong>工作站&lt;/strong>的系统上开发基础架构代码。Chef使用大量内置的DSL资源（例如：package，service，file，directory等操作系统资源分类）对目标节点的配置进行建模，代码可以映射到内部的用来执行这些代码的各种&lt;strong>提供者&lt;/strong>上。&lt;/p>
&lt;p>所能实现的示例代码如下所示，下面是配置Linux操作系统中的Apache服务器。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">package&lt;/span> &lt;span class="s1">&amp;#39;httpd&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">action&lt;/span> &lt;span class="ss">:install&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">service&lt;/span> &lt;span class="s1">&amp;#39;httpd&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">action&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="ss">:enable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:start&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是在Linux操作系统里配置 &lt;code>/a/b/c&lt;/code> 目录&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">directory&lt;/span> &lt;span class="s1">&amp;#39;/a/b/c&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">owner&lt;/span> &lt;span class="s1">&amp;#39;admin&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">group&lt;/span> &lt;span class="s1">&amp;#39;admin&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mode&lt;/span> &lt;span class="s1">&amp;#39;0755&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">action&lt;/span> &lt;span class="ss">:create&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">recursive&lt;/span> &lt;span class="kp">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以下面就是 &lt;code>/a/b/c&lt;/code> 目录的配置结果状态：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">$ls&lt;/span> ‐ld /a/b/c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">drwxr-­‐xr-­‐x. &lt;span class="m">5&lt;/span> admin admin &lt;span class="m">4096&lt;/span> Feb &lt;span class="m">14&lt;/span> 11:22 /a/b/c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Chef其它的重要术语：&lt;/p>
&lt;ul>
&lt;li>recipe ：包含了一个或者对个资源描述定义（Chef预定义了文件、用户、软件包、服务等等资源，可以扩展开发自定义资源类）&lt;/li>
&lt;li>cookbook ：包含了一个或多个recipe配方&lt;/li>
&lt;li>data bag ：包含了一个或多个配置数据点(data bag item)，是JSON格式，一个cookbook食谱可以包含一个或者多个数据袋&lt;/li>
&lt;li>run list ：包含了一个或者多个cookbook食谱，可将其部署在被管理的node节点上&lt;/li>
&lt;li>role ：一组特定内容的run list运行清单构成了一个角色&lt;/li>
&lt;li>environments：同我们现在对环境的定义，并可以一一对应起来&lt;/li>
&lt;/ul>
&lt;p>Chef是偏主机配置管理的非常的Iac语言，它具有很丰富的扩展能力和生态系统。它有很好的扩展能力，很强的逻辑性，能够进行深度的表达和锻造。它和Terraform和Ansible都有较大差异。&lt;/p>
&lt;h2 id="部署流程设计">部署流程设计
&lt;/h2>&lt;p>将以上手工处理过程转换为自动化执行的、一键式触发或者自动触发的流程需要关注很多个要点。&lt;/p>
&lt;p>使用Chef部署自开发的应用程序，包括配置所依赖的操作系统配置和软件，以及自身所需的应用配置。可以使用Liquibase进行数据库的schema部署和更新。可以用Jenkins协调和组织所有工序的执行。使用Jenkins管理部署流程的感觉和用它执行CI是类似。&lt;/p>
&lt;p>从简单开始，尽量将一组彼此相关的、版本化的可部署物组织在一起发布，例如在一个发布集合中可以包含：UI、REST服务器、消息服务和数据库。尽量使用一条命令构建，使用一条命令部署。&lt;/p>
&lt;h3 id="cookbook设计类型">Cookbook设计类型
&lt;/h3>&lt;p>&lt;strong>Library Cookbook 库食谱&lt;/strong> ：这种类型的食谱涵盖了通用的、可重用的逻辑。例如所有配置基线，也可以是安全基线。例如：dns、ntp、主机登录提示、用户和组、禁用服务清单等等。开发扩展的自定义chef资源，用来部署自开发应用。&lt;/p>
&lt;p>&lt;strong>Application Cookbook 应用系统食谱&lt;/strong> ：在以上库食谱的基础上，为一个套应用系统开发一个Cookbook食谱，每个应用可是一个recipe配方，recipe配方使用自定义开发的Chef资源。这样就形成了非常轻量的代码库。&lt;/p>
&lt;p>&lt;strong>Data Bag 数据袋&lt;/strong>：包含了各种应用配置，例如：服务端口、JAVA_OPTS等等。一个应用系统Cookbook食谱对应一个数据袋，袋子里面包含了该应用在每一套环境里的相关所有配置点。&lt;/p>
&lt;p>上线一个应用的新版本意味着新版本IaC代码的更新和部署，大致的流程是：编辑Chef代码、推送到Chef管理服务器、在节点上运行Chef客户端程序执行部署动作。Chef服务器的版本始终和版本控制库里的Master主干保持一致，这同样意味着环境配置和Master主干代码保持一致。&lt;/p>
&lt;p>用Chef开发自定义应用资源的实例代码如下，这段代码表示了一个Java应用war包的部署。&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/carbon.png"
loading="lazy"
alt="carbon"
>&lt;/p>
&lt;p>基于类似于以上的自定义资源类型，在必要的情况下，还可以对其开发Action（chef资源的操作），可能的操作定义有：&lt;/p>
&lt;ul>
&lt;li>从Artifactory服务器下载Java、Tomcat和WAR包。&lt;/li>
&lt;li>在标准的路径安装Java和Tomcat。&lt;/li>
&lt;li>创建和配置Tomcat容器&lt;/li>
&lt;li>在特定的容器里安装WAR包&lt;/li>
&lt;li>在主机上开防火墙端口&lt;/li>
&lt;li>生成应用属性文件&lt;/li>
&lt;li>启动Tomcat容器&lt;/li>
&lt;/ul>
&lt;p>Data Bag数据袋的实例代码结构如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;version&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;1.4.9&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;runtime&amp;#34;&lt;/span>&lt;span class="p">:{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;my-­app-­ui&amp;#34;&lt;/span>&lt;span class="p">:{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;java_opts&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;-­‐Xmx2G -­‐XX:MaxPermSize=1024m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;app_config&amp;#34;&lt;/span>&lt;span class="p">:{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;db.url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;jdbc:postgresql://devdb:5432/myapp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;svc.foo.url&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;http://devsvc:9000/foo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上是data_bags/my_app/DEV.json的定义，还可以有其它环境的定义data_bags/my_app/TEST.json和data_bags/my_app/PROD.json等。&lt;/p>
&lt;h2 id="人员角色">人员角色
&lt;/h2>&lt;p>基础架构的持续集成需要Dev和Ops的相互协作，才能做通，才能全面覆盖应用所需要的技术栈。&lt;/p>
&lt;p>&lt;strong>部署人员&lt;/strong> 更data_bag新数据袋和环境定义文件，触发生产环境部署的动作，调度chef-client客户端的运行，或者推送新版本的Chef代码更新。&lt;/p>
&lt;p>&lt;strong>技术负责人&lt;/strong> 维护应用系统Cookbook食谱。&lt;/p>
&lt;p>&lt;strong>框架开发人员&lt;/strong> 维护库Cookbook食谱，维护框架，持续改进流程。&lt;/p>
&lt;p>以上这三种角色，从上到下是从Ops到Dev的过渡。对于传统IT组织的架构，部署人员是Ops团队的，框架开发人员是Dev团队的。&lt;/p>
&lt;p>这三种角色都凑齐了，才能起到全套应用系统的整体建模和编码，而且每个角色都有负责的部分。技术负责人可能是来自Ops和Dev团队的技术大拿。他们对整体的正确性和完整性负责。&lt;/p>
&lt;p>目前也有Dev团队在其内部招聘运维研发的角色。这三种角色是基础架构即代码的层次结构和人员团队架构的对应，在实际工作中可以灵活应用；一方面覆盖所有技术层次，另外一方面引入所有必要的人员，是团队形成合力。&lt;/p>
&lt;p>如果不是本着将全套应用系统做全量的部署，以上任何角色做自己职责范围内的IaC自动化实践，其实效果是事倍功半的，或者机会只有技术学习和探索的价值。&lt;/p>
&lt;h2 id="构建cookbook">构建Cookbook
&lt;/h2>&lt;p>在开发了各种Cookbook之后，我们就需要对其进行持续测试，因此就需要使用Cookbook的持续构建流程。这个步骤就如同我们对应用程序的代码做CI一样。&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/cookbook-build.png"
loading="lazy"
alt="cookbook-build"
>&lt;/p>
&lt;p>开发人员（程序员不是业务应用开发者的专业名词，这里指IaC开发者，可能来自任何团队）在Workstations工作站上开发Chef的Cookbook代码，将代码提交到GitHub上的Chef代码仓库。&lt;/p>
&lt;p>Jenkins的Master服务器会触发CI Job，调用Ruby Slave对Cookbook代码进行集成和测试，然后触发EC2临时实例的创建，将Cookbook在EC2实例中进行测试，使用Artifactory中存储的应用软件包部署应用。如果测试都通过了，就触发Release Job，它将Cookbook代码上传到Chef服务器，供所各种环境中的被管理节点使用。&lt;/p>
&lt;p>上图用EC2作为Chef代码的CI环境，可以替代的方案有Vagrant+虚拟化（Virtual Box或者kvm），或者使用其它虚拟机资源池，如Ovirt KVM、Xen、Nutanix。我实际测试过使用Terraform对接Nutanix资源池，虚拟机创建超级快，几乎是秒得的速度。现有的虚拟化资源池就是最方便的对接对象，需要了解一下API和对接工具即可。&lt;/p>
&lt;p>对于Jenkins构建服务器而言，每一套应用系统对应的Cookbook组/集合的测试和发布都会在同一个构建服务器上发生，一般情况下这个服务器也是这些应用的CI服务器；这个Jenkins服务器也是相关Cookbook的CI作业和发布作业的运行地点。这个服务器上会安装所需要的Ruby gem包，应该能访问到与Chef服务器链接所需要的秘钥；应该可以使用到创建EC2测试节点虚拟机的秘钥，或者说访问其他类型虚拟机资源池的用户名和密码。&lt;/p>
&lt;h3 id="cookbook-ci-job">Cookbook CI Job
&lt;/h3>&lt;p>Cookbook CI作业的触发条件是：当有新Chef代码被合并的时候。它会进静态代码扫码和测试工作，包括如下内容：&lt;/p>
&lt;ul>
&lt;li>使用json和gem的相关工具分析JSON的句法&lt;/li>
&lt;li>使用Tailor做Ruby的句法和风格扫描&lt;/li>
&lt;li>使用Knife做Chef代码的句法分析&lt;/li>
&lt;li>使用Foodctritic做Che代码的句法分析和正确性分析&lt;/li>
&lt;/ul>
&lt;p>Chef代码在测试虚拟机里的集成测试是本文的重点，集成测试工具使用Test Kitchen，这个工具有一系列和虚拟化/云环境对接的插件，如 kitchen-ec2插件等。能按需临时的创建用于集成测试的虚拟机，在测试完毕，得出了测试结果之后，就删除本作业所创建的临时虚拟机。&lt;/p>
&lt;p>在集成测试的生命周期过程中也可能创建多个测试虚拟机/EC2实例，这个过程使对应用系统里的所有组件进行仿真的、实际的安装包和服务部署，进行单节点或者多节点的全量应用系统部署。在每个节点上都执行Chef代码，在Chef对应用系统的配置和部署完成之后，在对运行中的应用进行验证测试，测试包括测试相关的服务端口是否能访问，返回结果是否正常等等，Chef是可以进行测试驱动开发的，因此可以写出较细致的测试代码，从而分析本Cookbook集成测试通过与否。在测试结束了以后（最好是10分钟左右或更短），删除所有测试的虚拟机资源。&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/nutanix-logo.png"
loading="lazy"
alt="Nutanix"
>&lt;/p>
&lt;p>应该尽可能的优化这个集成测试，尽量缩短它的执行时间。可以创建专用的EC2-AMI/Nutanix/Kvm/VMWare操作系统镜像，预装所需要的Ruby环境和Chef工具。&lt;/p>
&lt;p>使用Chef Solo（不依赖chef服务器）执行Chef代码的测试，以免将临时节点也添加到了Chef服务器，同时也消除了Chef的客户端和服务器架构之间相互通讯的消耗，这个场景里其实没有使用Chef服务器的必要。使用一个名为CHEFDEV的伪环境来测试代码，而JSON文件里定义的真实环境则被保留用于正式生产环境。在创建EC2虚拟机的时候，给它们打上特定的标签，从而保持一定的可追踪性和环境的可维护性。&lt;/p>
&lt;h3 id="cookbook-release-job">Cookbook Release Job
&lt;/h3>&lt;p>这个作业的运行内容和CI Job基本一致的，而它是靠人为手工触发的，从Chef角度看，可以说：本文上述的所有描述，属于Chef风格的基础架构即代码程序的持续交付。本作业将测试成功的代码在GitHub/GitLab里打上标签，并且上传Cookbook的新版本到正式的Chef生产服务器上。&lt;/p>
&lt;p>可以想象经过多个Cookbook的build job之后，Cookbook的某个版本被发布到了生产环境中，用于环境的配置和应用的部署。本Job作业交付了IaC的开发结果到生产环境中的Chef管理服务器。&lt;/p>
&lt;p>其它IaC的基础架构持续及集成与本文描述的也应该是类似流程。&lt;/p>
&lt;h2 id="应用部署流程">应用部署流程
&lt;/h2>&lt;p>Cookbook的开发和集成完毕了以后，它的结果产物是一些列新版本的Cookbook代码，它们最终上传到Chef服务器。支持生产环境应用部署的Chef服务器与各种环境保持连接，包括测试、预发布和生产等等。&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/app-deploy-process.png"
loading="lazy"
alt="app-deploy-process"
>&lt;/p>
&lt;p>在发布过程中所使用到的制品是从Artifactory中拉取的。下面简单说下这个架构中的关键点。&lt;/p>
&lt;p>&lt;strong>Jenkins部署服务器&lt;/strong> 这是专门用于各种部署工作的Jenkins Master服务器，它和上一个步骤里Cookbook的Build服务器是不同的。它的Slave应该满足这些需求：安装了所需要Ruby环境和gem包。安装了Chef工具，并且具有能更新Chef服务器的秘钥。具有能访问各种虚拟化环境中节点的SSH秘钥。&lt;/p>
&lt;p>&lt;strong>部署作业的类型&lt;/strong> 可以对于每一个应用组（一套应用系统）设置两个部署作业：在开发环境中的，用于开发人员使用的DEV部署作业；另外是运维人员所使用的Non-Dev部署作业。在实践过程中也能发展出其他类型。&lt;/p>
&lt;p>部署人员的工作流程：&lt;/p>
&lt;ol>
&lt;li>变更Chef相关代码和配置，包括：编辑应用的data bag配置数据点，有必要的话编辑环境文件，合并代码。&lt;/li>
&lt;li>然后在Jenkins部署服务器上执行作业。&lt;/li>
&lt;/ol>
&lt;p>通过以上的流程和工具，开发、测试和运维的相关人员，如果需要部署应用了，就可以用一键式的、自助式的部署模式，将任何应用应用系统通过一键式的方式自动化的部署到各种应用环境中。&lt;/p>
&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/push-button-deploy.png"
loading="lazy"
alt="push-button-deploy"
>&lt;/p>
&lt;p>这样我们将大量各种角色人员都从事的、没有附加值的应用部署工作，彻底的消灭掉了，节省的时间可以用来做更多有意义的工作，Dev人员有更多时间编码、测试人员不需要等待时间、运维人员也降低的工作压力。&lt;/p>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>关于基础架构的持续集成，还有下列值得参考的原则：&lt;/p>
&lt;ul>
&lt;li>尽可能的标准化：包括技术、设计和流程等方面；要能够支持环境的规模化扩展，例外是可以的，但是要尽量避免。&lt;/li>
&lt;li>所有工具最好有API：避免在某个工具，在工具链上的任何环节的脱节。&lt;/li>
&lt;li>使用多种形式的沟通路径：这个实践需要用各种方式进行宣传和推广，包括：全员大会的主题分享、每个团队的启动会议、与开发人员的随时沟通，使用文档进行知识传播和沟通。&lt;/li>
&lt;li>保持乐观，尽量发现和找到那些志同道合的早期响应者，让他们和你站在一条战线上。&lt;/li>
&lt;/ul>
&lt;h2 id="引用">引用
&lt;/h2>&lt;h3 id="参考视频">参考视频
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=PQ6KTRgAeMU" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=PQ6KTRgAeMU
&lt;/a>&lt;/p>
&lt;h3 id="参考书籍">参考书籍
&lt;/h3>&lt;p>&lt;img src="https://res.cloudinary.com/martinliu/image/upload/book-infrastructure-as-code.png"
loading="lazy"
>&lt;/p>
&lt;hr></description></item><item><title>BMC Atrium CMDB CI数据迁移</title><link>https://martinliu.cn/2011/01/12/bmc-atrium-cmdb-ci/</link><pubDate>Wed, 12 Jan 2011 05:08:23 +0000</pubDate><guid>https://martinliu.cn/2011/01/12/bmc-atrium-cmdb-ci/</guid><description>&lt;p>在不同的 CMDB 服务器之间做数据迁移之前一定要注意两点：1）保持两边的 CDM 相同；2）先导入 CI 数据在导入 CI 相关的关系数据。另外就是每个类导入完毕之后要做数据完整性和正确性的抽检。以下使用的工具是 cmdbdriver，该命令初始化和一般性的参数介绍请参考相关文档。&lt;/p>
&lt;p>&lt;em>&lt;strong>CI 数据导出示例&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Command: xexpdt
XEXPORT DATA
Export instance data from all classes? (F):
Classes to export data from:
Class and its subclasses, From namespace (1,2) (1):
Namespace (): BMC.CORE
Class name (): BMC_ComputerSystem
Dataset ID (): BMC.ASSET
Filename for exported data: C:\DEMO\cs-ci
Exporting Class BMC_ComputerSystem
i=0: namespaceName = BMC.CORE, className = BMC_ComputerSystemExported without errorsExporting Class BMC_MainframeExporti
ng Class BMC_PrinterExporting Class BMC_StorageSubsystem
CMDBExportData  results
ReturnCode:  OK
Status List : 0 items&lt;/p>
&lt;p>到相应目录下面找到导出的文件，导出的结果至少是两个文件一个是 META_FILE 其他的才是 CI 数据文件。&lt;/p>
&lt;p>&lt;em>&lt;strong>关系数据导出示例&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Command: xexpdt
XEXPORT DATA
Export instance data from all classes? (F):
Classes to export data from:
Class and its subclasses, From namespace (1,2) (1):
Namespace (): BMC.CORE
Class name (): BMC_Dependency
Dataset ID (): BMC.ASSET
Filename for exported data: C:\DEMO\REL-DEP.XML
Exporting Class BMC_Dependency
i=0: namespaceName = BMC.CORE, className = BMC_DependencyExported without errorsExporting Class BMC_AccountOnSystemExpor
ting Class BMC_HostedAccessPointExporting Class BMC_HostedServiceExporting Class BMC_InventoryBulkItemsExporting Class B
MC_InventoryComputerSystemsExporting Class BMC_InventoryEquipmentExporting Class BMC_InventorySystemComponents
CMDBExportData  results
ReturnCode:  OK
Status List : 0 items&lt;/p>
&lt;p>到相应目录下面找到导出的文件，导出的结果至少是两个文件一个是 META_FILE 其他的才是 CI 数据文件。&lt;/p>
&lt;p>&lt;em>&lt;strong>导入数据示例&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Command: impdt
IMPORT INSTANCE DATA
Handle duplicate Instance Ids:
(Error/New ID for Dup/Merge/New ID for All) (1-4) (1): 3
Filename containing import data: c:\demo\cs-ci_0_0  (导入包含 CI 数据的文件)&lt;/p>
&lt;p>CMDBImportData  results
ReturnCode:  OK
Status List : 0 items
Total items Processed             :  2
Items Imported successfully       :  2
Items for which Import failed     :  0&lt;/p>
&lt;p>Command: impdt
IMPORT INSTANCE DATA
Handle duplicate Instance Ids:
(Error/New ID for Dup/Merge/New ID for All) (1-4) (1): 3
Filename containing import data: c:\demo\REL-DEP.XML_0_0 (导入包含关系数据的文件)&lt;/p>
&lt;p>CMDBImportData  results
ReturnCode:  OK
Status List : 0 items
Total items Processed             :  1
Items Imported successfully       :  1
Items for which Import failed     :  0&lt;/p>
&lt;p>导入完毕之后使用 Remedy User 到相应的表格中查找，确认导入的数据是否正确。&lt;/p></description></item><item><title>规划CMDB数据填充-001</title><link>https://martinliu.cn/2010/06/04/plan-cmdb-population-001/</link><pubDate>Fri, 04 Jun 2010 06:13:20 +0000</pubDate><guid>https://martinliu.cn/2010/06/04/plan-cmdb-population-001/</guid><description>&lt;p>From 《Step by step to build a CMDB》步骤 17-规划 CMDB 数据填充&lt;/p>
&lt;p>目标&lt;/p>
&lt;p>在这一 CMDB 关键的步骤中，会为 CMDB 的初始化 CI 数据填充，做精细的计划。需要考虑到所有 CI 数据，把不同 CI 类型对应到不同的数据集中，安排正确的顺序将这些数据集 CMDB。其中定义对应的规则来调和重复数据是很重要的，不仅在 CMDB 初始化数据填充阶段重要，在以后的日常维护过程中也是非常重要的。做出了本阶段的详细规划后，这样在第 18 步即“选择自动化 CMDB 填充工具”时，就能考虑需要什么样的配置发现和自动化工具了。&lt;/p>
&lt;p>&lt;img src="http://pursuitmag.com/wp-content/uploads/2010/01/private-investigator-database.jpg"
loading="lazy"
>&lt;/p>
&lt;p>实际上，把数据填充到 CMDB 中是非常基础的工作，必须事前做好充分的数据范围和类型的分析。对于一个典型的 CMDB 数据填过程来说，将需要做如下工作：&lt;/p>
&lt;ul>
&lt;li>建立里项目程碑和高阶项目计划，以及配套的支撑数据库和操作流程。&lt;/li>
&lt;li>安排项目启动会议，单周或者双周的项目进度沟通会。&lt;/li>
&lt;li>识别子项目（每个数据集分为一个子项目），建立每个子项目的目标和需求清单。识别和制定项目工作活动内容，确定项目的工作流程，并且按照项目计划排程所有活动。包括：
&amp;mdash;并行开展项目（用户界面定制，DSL 数据填充）；
&amp;mdash;串行开展项目（发现工具，数据调和，等等）&lt;/li>
&lt;li>为每个子项目分配项目负责人，让他们来负责汇报项目的进展、问题升级和下一步的工作。&lt;/li>
&lt;li>为所有项目参与人员建立一个开放的沟通平台，包括所有内部、外部人员（邮件组方式，数据库、通报）&lt;/li>
&lt;li>为可能出现的紧急事件预留至少 10%的时间和预算的缓冲。&lt;/li>
&lt;/ul>
&lt;p>自动配置采集工具是一种很好的数据填充和数据维护方式，您也会在某种发现工具的诱惑下，在很短的时间里，就采集到了大量的数据。可是您还是需要注意：一个被填充了大量数据的CMDB并不意味着是一个好CMDB。一旦您建立和填充了CMDB，您就将需要对它进行积极地维护。如果CMDB中存储着很多超出用户需求的数据，即使在最好的情况下，您也是对这些无用的数据做大量无谓创建和维护工作，这是一个巨大的浪费且没有意义的事。而在最糟的情况下，如果你所填充入CMDB的数据，在后来是没有被及时更新和维护的，那么当用户使用到这些质量低和不精确的数据数据后，就会对CMDB失去信心，这样也对 CMDB在企业里的推广和应用造成一定阻碍。&lt;/p>
&lt;p>按照您在第二步-“定义需求和创建 IT 服务模型蓝图”中的需求，来设计和部署 CMDB。从你的服务模型蓝图出发，来识别 CI，把他们分组到各个数据集中。识别每个数据集应该对应的数据源，把每个 CI 类型和相关数据源对应起来。并且按照既定的 CMDB 数据导入的工作顺序，来规划不同数据源中数据。最后，把以上所有规划和设计用文档记录下来，包括识别重复数据的调和规则等。&lt;/p>
&lt;p>在这一步里，您必须专注于 CMDB 所需要的范围，交付可实现的东西，而非可能的东西。在敲定最终的规划之前，你需要组织分析会议进行仔细地计划。&lt;/p></description></item></channel></rss>
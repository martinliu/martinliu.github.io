<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>云计算 on Martin Liu's Blog</title><link>https://martinliu.cn/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/</link><description>Recent content in 云计算 on Martin Liu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 18 Sep 2025 17:26:30 +0800</lastBuildDate><atom:link href="https://martinliu.cn/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/index.xml" rel="self" type="application/rss+xml"/><item><title>90% 的人 DevOps 转型失败：一份真正奏效的路线图</title><link>https://martinliu.cn/blog/90-of-people-fail-at-devops-heres-the-roadmap-that/</link><pubDate>Thu, 28 Aug 2025 10:00:00 +0800</pubDate><guid>https://martinliu.cn/blog/90-of-people-fail-at-devops-heres-the-roadmap-that/</guid><description>&lt;img src="https://martinliu.cn/blog/90-of-people-fail-at-devops-heres-the-roadmap-that/image_0_94126cb8.png" alt="Featured image of post 90% 的人 DevOps 转型失败：一份真正奏效的路线图" />&lt;p>几年前，我困在了一个没有前途的 Linux 技术支持岗位上，上夜班，看不到任何成长。尽管有9年经验，我的薪水却微薄，健康状况每况愈下，也没有社交生活。我眼看着大学同学在事业上平步青云，而我却仍旧陷在自己的舒适区里。&lt;/p>
&lt;p>但当我决定转型到 DevOps 时，一切都改变了。经过4-5个月的集中学习，我找到了一份薪水翻了3倍的工作。这种转变不仅仅是职业上的，更是个人生活上的。我找回了生活，重拾了自信，最终找到了既有挑战又令我兴奋的工作。&lt;/p>
&lt;p>今天，我想分享正是这个路线图，让我的转型成为可能。这不仅仅是另一篇泛泛的“学习这些工具”的文章——这是一条真实、经过实践检验的路径，它帮助我在没有任何该领域经验的情况下，成功进入了 DevOps (开发运维) 领域。&lt;/p>
&lt;h2 id="什么是-devops">什么是 DevOps？
&lt;/h2>&lt;p>简单来说，DevOps 是一种组织遵循的方法论 (methodology)，旨在将开发团队 (development team) 和运维团队 (operations team) 合并成一个统一的团队。通过这种方式，两个团队共同协作，高效地开发和部署应用程序。&lt;/p>
&lt;p>DevOps 是一个广义术语 (umbrella term)，它涵盖了各种用于自动化应用程序开发和部署过程的工具。DevOps 的主要好处之一是，通过自动化这些过程，与手动方法相比，它更省时，也更不容易出错。这种自动化缩短了产品上市时间 (Time to Market, TTM)，使其成为快速发展公司的理想选择。&lt;/p>
&lt;h2 id="你将面临哪些困难以及如何克服它们">你将面临哪些困难（以及如何克服它们）？
&lt;/h2>&lt;p>让我坦诚地谈谈你将遇到的挑战：&lt;/p>
&lt;p>&lt;strong>资源过多&lt;/strong> 最大的问题不是找不到教程，而是不知道该选择哪个！有成千上万的课程、博客和视频。你可能会浪费几周时间只为了决定学什么，结果反而更困惑，而不是取得进展。&lt;/p>
&lt;p>&lt;strong>到处都是糟糕的路线图&lt;/strong> 大多数在线学习路径要么过于简单（“只需学习 Docker！”），要么过于复杂（列出50多种工具）。你需要一个切合你初学者水平和繁忙日程的现实路线图。&lt;/p>
&lt;p>&lt;strong>试图一次性学完所有东西&lt;/strong> 你会想同时学习 Docker、Kubernetes、AWS 和 Terraform。这种跳跃式的学习会导致知识掌握不深，并带来倦怠。&lt;strong>一次只专注于一件事。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>工具过载和社媒喧嚣&lt;/strong>
你会看到人们每周都在社媒上谈论“最新最棒”的工具。不要落入这个陷阱。专注于核心基础知识，并首先掌握必要的工具。忽略这些喧嚣，保持简单——你不需要 20 种工具才能成功。&lt;/p>
&lt;p>&lt;strong>感到力不从心&lt;/strong>
DevOps 拥有大量的工具和令人困惑的术语。你有时会感到迷茫。别担心——即使是经验丰富的工程师也会有这种感觉。这是正常的，随着时间推移会好转。&lt;/p>
&lt;h2 id="完整的-6-个月-devops-路线图">完整的 6 个月 DevOps 路线图
&lt;/h2>&lt;p>本路线图旨在让你从完全的初学者成长为能够胜任工作的 DevOps 工程师。每个月的内容都在前一个月的基础上进行，在增加复杂性之前打下坚实的基础。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/blog/90-of-people-fail-at-devops-heres-the-roadmap-that/image_1_2eeeb884.png"
width="640"
height="427"
srcset="https://martinliu.cn/blog/90-of-people-fail-at-devops-heres-the-roadmap-that/image_1_2eeeb884_hu_998e192d4afb0653.png 480w, https://martinliu.cn/blog/90-of-people-fail-at-devops-heres-the-roadmap-that/image_1_2eeeb884_hu_fd4c3f5b3227c065.png 1024w"
loading="lazy"
alt="DevOps 6个月学习路线图"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="359px"
>&lt;/p>
&lt;h2 id="第一月基础技能--linux网络shell-脚本和-git">第一月：基础技能 — Linux、网络、Shell 脚本和 Git
&lt;/h2>&lt;p>&lt;strong>第 1-2 周：Linux 基础知识&lt;/strong> Linux 构成了大多数 DevOps 基础设施 (infrastructure) 的支柱。首先学习你作为 DevOps 工程师每天都会用到的基本命令行技能。&lt;/p>
&lt;p>需要掌握的关键技能：&lt;/p>
&lt;ul>
&lt;li>文件和目录管理 (ls, cd, mkdir, rm, cp, mv)&lt;/li>
&lt;li>文件权限和所有权 (chmod, chown, umask)&lt;/li>
&lt;li>进程管理 (ps, top, htop, kill, jobs)&lt;/li>
&lt;li>系统监控 (df, du, free, uptime, iostat)&lt;/li>
&lt;li>文本处理工具 (grep, awk, sed, cut, sort, uniq)&lt;/li>
&lt;li>包管理 (apt, yum, rpm)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 3 周：网络基础知识&lt;/strong> 理解网络对于故障排除和设计可扩展系统至关重要。&lt;/p>
&lt;p>基本网络概念：&lt;/p>
&lt;ul>
&lt;li>IP 地址和子网划分 (IPv4, IPv6)&lt;/li>
&lt;li>OSI 模型 (OSI model) 和 TCP/IP 协议栈 (TCP/IP stack)&lt;/li>
&lt;li>DNS 解析 (DNS resolution) 和配置&lt;/li>
&lt;li>网络诊断工具 (ping, traceroute, netstat, ss)&lt;/li>
&lt;li>防火墙 (Firewall) 和安全组 (Security Group)&lt;/li>
&lt;li>负载均衡 (Load Balancing) 概念&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 4 周：Shell 脚本和 Git&lt;/strong> 通过脚本实现自动化和版本控制是基本的 DevOps 技能。&lt;/p>
&lt;p>Shell 脚本技能：&lt;/p>
&lt;ul>
&lt;li>变量 (Variable) 和环境变量 (Environment Variable)&lt;/li>
&lt;li>控制结构 (if/else, 循环, case 语句)&lt;/li>
&lt;li>函数 (Function) 和脚本组织&lt;/li>
&lt;li>错误处理和退出码 (Exit Code)&lt;/li>
&lt;li>Cron 任务 (Cron Job) 和任务调度&lt;/li>
&lt;/ul>
&lt;p>Git 版本控制：&lt;/p>
&lt;ul>
&lt;li>仓库初始化和克隆&lt;/li>
&lt;li>基本命令 (add, commit, push, pull, status)&lt;/li>
&lt;li>分支策略和合并&lt;/li>
&lt;li>冲突解决&lt;/li>
&lt;li>GitHub 工作流 (workflow) 和协作&lt;/li>
&lt;/ul>
&lt;h2 id="第二月云平台和容器化">第二月：云平台和容器化
&lt;/h2>&lt;p>&lt;strong>第 1-2 周：AWS 云基础知识&lt;/strong> 专注于一个主要的云平台来建立深厚的专业知识。AWS 在市场中处于领先地位，使其成为初学者的最佳选择。&lt;/p>
&lt;p>核心 AWS 服务：&lt;/p>
&lt;ul>
&lt;li>EC2 (弹性计算云) 用于虚拟服务器&lt;/li>
&lt;li>VPC (虚拟私有云) 用于网络&lt;/li>
&lt;li>S3 (简单存储服务) 用于对象存储&lt;/li>
&lt;li>IAM (身份和访问管理) 用于安全&lt;/li>
&lt;li>RDS (关系型数据库服务) 用于托管数据库&lt;/li>
&lt;li>负载均衡器 (ALB, NLB) 用于流量分发&lt;/li>
&lt;li>自动扩缩组 (Auto Scaling Groups) 用于弹性&lt;/li>
&lt;li>CloudWatch 用于监控和日志记录&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 3-4 周：Docker 容器化&lt;/strong> 容器化通过在不同阶段提供一致的环境，彻底改变了应用程序部署方式。&lt;/p>
&lt;p>Docker 基础：&lt;/p>
&lt;ul>
&lt;li>容器与虚拟机概念&lt;/li>
&lt;li>Docker 架构和组件&lt;/li>
&lt;li>镜像创建与管理&lt;/li>
&lt;li>Dockerfile 最佳实践和优化&lt;/li>
&lt;li>容器网络和卷&lt;/li>
&lt;li>注册表管理 (Docker Hub, ECR)&lt;/li>
&lt;/ul>
&lt;p>Docker Compose：&lt;/p>
&lt;ul>
&lt;li>多容器应用编排&lt;/li>
&lt;li>服务定义和网络&lt;/li>
&lt;li>环境变量和 Secrets 管理&lt;/li>
&lt;li>卷挂载和数据持久化&lt;/li>
&lt;/ul>
&lt;h2 id="第三个月基础设施即代码和-cicd-自动化">第三个月：基础设施即代码和 CI/CD 自动化
&lt;/h2>&lt;p>&lt;strong>第 1-2 周：使用 Terraform 实现基础设施即代码&lt;/strong>&lt;/p>
&lt;p>基础设施即代码 (IaC) 是区分初级 DevOps 工程师和高级专业人士的关键。&lt;/p>
&lt;p>Terraform 要点：&lt;/p>
&lt;ul>
&lt;li>Terraform (HCL) 语法&lt;/li>
&lt;li>Provider 和资源管理&lt;/li>
&lt;li>状态管理和远程后端&lt;/li>
&lt;li>变量、输出和数据源&lt;/li>
&lt;li>模块化可重用基础设施&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 3 周：使用 GitHub Actions 实现 CI/CD&lt;/strong>&lt;/p>
&lt;p>持续集成 (Continuous Integration) 和持续部署 (Continuous Deployment) 自动化了软件交付管道。&lt;/p>
&lt;p>CI/CD 管道组件：&lt;/p>
&lt;ul>
&lt;li>工作流触发器和事件&lt;/li>
&lt;li>作业 (Jobs)、步骤 (Steps) 和操作 (Actions)&lt;/li>
&lt;li>针对多环境的矩阵构建 (Matrix Builds)&lt;/li>
&lt;li>Secrets 和环境变量管理&lt;/li>
&lt;li>部署策略 (滚动部署、蓝绿部署、金丝雀部署)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 4 周：AWS ECS 容器编排&lt;/strong>&lt;/p>
&lt;p>在初期阶段，学习容器编排可以避开 Kubernetes 的复杂性。&lt;/p>
&lt;p>ECS 基础：&lt;/p>
&lt;ul>
&lt;li>集群管理和容量提供程序 (Capacity Providers)&lt;/li>
&lt;li>任务定义和服务配置&lt;/li>
&lt;li>服务发现和负载均衡&lt;/li>
&lt;li>自动扩缩策略和方案&lt;/li>
&lt;/ul>
&lt;h2 id="第四个月kubernetes-生态系统和高级编排">第四个月：Kubernetes 生态系统和高级编排
&lt;/h2>&lt;p>&lt;strong>第 1 周：Kubernetes 基础&lt;/strong>&lt;/p>
&lt;p>Kubernetes 是大规模容器编排的行业标准。&lt;/p>
&lt;p>Kubernetes 核心概念：&lt;/p>
&lt;ul>
&lt;li>集群架构 (主节点、工作节点、etcd)&lt;/li>
&lt;li>Pods、Deployments 和 ReplicaSets&lt;/li>
&lt;li>Services 和 Ingress 控制器&lt;/li>
&lt;li>用于配置的 ConfigMaps 和 Secrets&lt;/li>
&lt;li>持久卷 (Persistent Volumes) 和存储类 (Storage Classes)&lt;/li>
&lt;li>用于资源隔离的命名空间 (Namespaces)&lt;/li>
&lt;li>RBAC (基于角色的访问控制)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 2 周：Kubernetes 高级特性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用于有状态应用的 StatefulSets&lt;/li>
&lt;li>用于节点级服务的 DaemonSets&lt;/li>
&lt;li>用于批处理的 Jobs 和 CronJobs&lt;/li>
&lt;li>水平 Pod 自动扩缩 (Horizontal Pod Autoscaling, HPA)&lt;/li>
&lt;li>用于流量控制的网络策略 (Network Policies)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 3 周：使用 Prometheus 和 Grafana 进行监控&lt;/strong>&lt;/p>
&lt;p>可观测性 (Observability) 对于维护大规模可靠系统至关重要。&lt;/p>
&lt;p>Prometheus 监控：&lt;/p>
&lt;ul>
&lt;li>指标收集和存储&lt;/li>
&lt;li>服务发现配置&lt;/li>
&lt;li>告警规则和通知路由&lt;/li>
&lt;/ul>
&lt;p>Grafana 可视化：&lt;/p>
&lt;ul>
&lt;li>仪表盘创建和模板化&lt;/li>
&lt;li>面板类型和可视化选项&lt;/li>
&lt;li>告警管理和通知渠道&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 4 周：使用 ArgoCD 和 Helm 进行 GitOps&lt;/strong>&lt;/p>
&lt;p>GitOps 代表了部署自动化的未来。&lt;/p>
&lt;p>ArgoCD 实现：&lt;/p>
&lt;ul>
&lt;li>GitOps 原则和工作流&lt;/li>
&lt;li>应用定义和同步策略&lt;/li>
&lt;li>多集群管理&lt;/li>
&lt;li>渐进式交付策略&lt;/li>
&lt;/ul>
&lt;p>Helm 包管理：&lt;/p>
&lt;ul>
&lt;li>Chart 结构和模板化&lt;/li>
&lt;li>Values 文件和环境定制&lt;/li>
&lt;li>Chart 仓库和分发&lt;/li>
&lt;/ul>
&lt;h2 id="第五个月python-自动化和事件驱动架构">第五个月：Python 自动化和事件驱动架构
&lt;/h2>&lt;p>&lt;strong>第 1-2 周：用于 DevOps 自动化的 Python&lt;/strong>&lt;/p>
&lt;p>Python 因其简洁性和丰富的库生态系统而成为 DevOps 自动化的首选语言。&lt;/p>
&lt;p>Python DevOps 要点：&lt;/p>
&lt;ul>
&lt;li>自动化所需的 Python 基础知识&lt;/li>
&lt;li>使用 API 和 JSON 数据&lt;/li>
&lt;li>错误处理和日志记录最佳实践&lt;/li>
&lt;li>用于云自动化的 AWS SDK (boto3)&lt;/li>
&lt;li>基础设施自动化脚本&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 2 周：AWS Lambda 和无服务器架构&lt;/strong>&lt;/p>
&lt;p>无服务器计算 (Serverless Computing) 消除了基础设施管理开销。&lt;/p>
&lt;p>Lambda 基础：&lt;/p>
&lt;ul>
&lt;li>函数创建和部署&lt;/li>
&lt;li>事件源和触发器&lt;/li>
&lt;li>环境变量和配置&lt;/li>
&lt;li>性能优化和冷启动&lt;/li>
&lt;/ul>
&lt;p>事件驱动架构：&lt;/p>
&lt;ul>
&lt;li>用于消息队列的 Amazon SQS&lt;/li>
&lt;li>用于发布/订阅消息的 Amazon SNS&lt;/li>
&lt;li>用于事件路由的 Amazon EventBridge&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第 3-4 周：高级无服务器模式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用于工作流编排的 Step Functions&lt;/li>
&lt;li>API Gateway 集成&lt;/li>
&lt;li>成本优化策略&lt;/li>
&lt;/ul>
&lt;h2 id="第六个月真实项目和求职准备">第六个月：真实项目和求职准备
&lt;/h2>&lt;p>最后一个月将专注于构建一个项目作品集，以展示你解决实际业务问题的能力。&lt;/p>
&lt;p>&lt;strong>能让你获得工作的 5 个项目作品集：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>自动化基础设施监控与告警系统&lt;/strong>&lt;/li>
&lt;li>&lt;strong>基于 GitOps 自动化（GitOps Automation）的多环境基础设施&lt;/strong>&lt;/li>
&lt;li>&lt;strong>容器化微服务平台（Containerized Microservices Platform）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>事件驱动的无服务器（Serverless）数据处理管线&lt;/strong>&lt;/li>
&lt;li>&lt;strong>带合规自动化（Compliance Automation）的 DevSecOps（开发安全运维一体化）管线&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>求职准备策略：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简历优化，突出量化成就&lt;/li>
&lt;li>GitHub 作品集开发，包含清晰且文档完善的代码仓库&lt;/li>
&lt;li>面试准备，重点关注场景题&lt;/li>
&lt;li>拓展人脉和参与社区活动&lt;/li>
&lt;/ul>
&lt;h2 id="成功的心智框架">成功的心智框架
&lt;/h2>&lt;p>&lt;strong>第 1–3 个月：一次精通一个工具&lt;/strong> 不要试图同时学习多个工具。你的大脑需要时间为每个新概念建立神经通路（neural pathways）。全身心投入一个工具，直到你觉得运用自如，然后再转向下一个。&lt;/p>
&lt;p>&lt;strong>第 4–5 个月：开始在项目中混合使用工具&lt;/strong> 既然你已经打下了坚实的基础，就可以开始组合使用工具了。构建使用 Docker + AWS，或者 Terraform + Kubernetes 的项目。奇迹将在此发生——你将理解工具是如何协同工作的。&lt;/p>
&lt;p>&lt;strong>第 6 个月：复杂项目与面试准备&lt;/strong> 构建能够解决实际业务问题的出色项目。练习向他人解释你的工作。通过理解不仅是工具的使用方法，更是你选择这些工具的原因，来准备技术面试。&lt;/p>
&lt;h2 id="如何欺骗你的大脑在学习中不感到不知所措">如何欺骗你的大脑，在学习中不感到不知所措
&lt;/h2>&lt;ul>
&lt;li>有些日子你觉得自己是天才，有些日子你觉得自己一无所知。这两种感觉都很正常，也是学习过程的一部分。关键在于持之以恒，即使在动力不足时也要坚持下去。&lt;/li>
&lt;li>不要被庞大的工具和技术生态系统所压倒。相反，一次只关注一件事，持续构建，并相信这个过程。&lt;/li>
&lt;li>当学习感觉不可能，你的大脑快要爆炸时，请休息一下。看看 Netflix，散散步，睡一觉。第二天或几天后再回来，突然间那个“不可能”的概念就会豁然开朗。&lt;/li>
&lt;/ul>
&lt;p>请记住，在前 3 个月，抵制过度思考或在工具之间跳跃的冲动。掌握基础知识。在第 4-5 个月，开始在实际项目中混合使用工具。第 6 个月是关于构建令人印象深刻的项目作品集并为面试做准备。&lt;/p>
&lt;h2 id="结论">结论
&lt;/h2>&lt;p>你的现状，无论是死胡同般的工作、低薪，还是缺乏职业成长，除非你采取行动，否则一切都不会改变。我分享的这条路并不容易，但它已被证明是有效的。我曾走过这条路，数百人也同样如此。&lt;/p>
&lt;p>&lt;strong>如果你不做出改变，一切都不会改变。&lt;/strong>&lt;/p></description></item><item><title>AWS VPC 和 IP Address 的秘密：2025 年DevOps工程师必知</title><link>https://martinliu.cn/blog/aws-vpc-ip-address-secrets-what-every-engineer/</link><pubDate>Thu, 28 Aug 2025 10:00:00 +0800</pubDate><guid>https://martinliu.cn/blog/aws-vpc-ip-address-secrets-what-every-engineer/</guid><description>&lt;img src="https://martinliu.cn/blog/aws-vpc-ip-address-secrets-what-every-engineer/1_S9_CChjGu1uWc_wnNUGxzw.webp" alt="Featured image of post AWS VPC 和 IP Address 的秘密：2025 年DevOps工程师必知" />&lt;p>像专家一样学习 AWS VPC IP 地址分配。探索隐藏规则、专家技巧和 2025 年最佳实践，以设计安全、可扩展的 AWS 网络。DevOps 和云工程师的完美指南。&lt;/p>
&lt;p>当大多数工程师启动一个新的 &lt;strong>AWS 虚拟私有云 (Virtual Private Cloud - VPC)&lt;/strong> 时，他们会直接选择经典的 &lt;code>/16&lt;/code> CIDR 块。
为什么？因为它“感觉很安全”——&lt;strong>65,536 个 IP 地址&lt;/strong>都在一个整齐的范围内。
不缺地址，没有规划烦恼……至少看起来是这样。&lt;/p>
&lt;p>但现实是：在 AWS 网络中，&lt;strong>CIDR 块大小的选择并非一劳永逸&lt;/strong>。错误的决策可能导致 &lt;strong>IP 地址耗尽、集成失败、安全漏洞和痛苦的迁移&lt;/strong>。而且，AWS 仍然隐藏着&lt;strong>一个小的 IP 秘密&lt;/strong>，这个秘密总是让新工程师头疼。&lt;/p>
&lt;h3 id="2025-年-cidr-范围规划为何更加重要">2025 年 CIDR 范围规划为何更加重要
&lt;/h3>&lt;p>您的 VPC CIDR 范围定义了您&lt;strong>有多少私有 IP 地址&lt;/strong>——以及这些地址如何被使用、划分并与其他网络集成。&lt;/p>
&lt;p>太多工程师仍然选择 &lt;code>10.0.0.0/16&lt;/code>，然后就此作罢。问题出在哪里？&lt;/p>
&lt;ul>
&lt;li>与企业本地网络重叠&lt;/li>
&lt;li>在 VPC 对等连接 (VPC Peering) 或中转网关 (Transit Gateway) 期间与其他 AWS 账户发生冲突&lt;/li>
&lt;li>当您扩展到多个区域时限制了增长&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2025 年最佳实践：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>创造性地使用 &lt;strong>RFC 1918&lt;/strong> 范围 (&lt;code>172.16.0.0/12&lt;/code> 或 &lt;code>192.168.0.0/16&lt;/code>)&lt;/li>
&lt;li>不要将 RFC 6598 (100.64.0.0/10) 用于 AWS VPC 或企业私有工作负载，它已被 ISP 保留用于运营商级 NAT (Carrier-Grade NAT)（根据 RFC 6598）。请坚持使用 RFC 1918 范围进行 VPC 设计。&lt;/li>
&lt;li>在&lt;strong>组织层面&lt;/strong>而非每个团队层面记录和预留 CIDR 块&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CIDR 块&lt;/th>
&lt;th>总 IP 数&lt;/th>
&lt;th>可用 IP 数 (AWS 保留后)&lt;/th>
&lt;th>最适用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>/16&lt;/code>&lt;/td>
&lt;td>65,536&lt;/td>
&lt;td>65,531&lt;/td>
&lt;td>大型多服务环境&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>/24&lt;/code>&lt;/td>
&lt;td>256&lt;/td>
&lt;td>251&lt;/td>
&lt;td>小型生产工作负载&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>/28&lt;/code>&lt;/td>
&lt;td>16&lt;/td>
&lt;td>11&lt;/td>
&lt;td>测试/沙箱环境&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>为什么这个选择在今天比以往任何时候都更重要：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>容器 (Containers) 和微服务 (Microservices)&lt;/strong>：在 EKS 和 ECS 中，&lt;strong>每个 Pod/任务 (pod/task) 都会获得自己的 IP&lt;/strong>（默认情况下），这使得小规模子网会 &lt;em>很快&lt;/em> 被占满。&lt;/li>
&lt;li>&lt;strong>AWS PrivateLink 和 VPC Lattice&lt;/strong>：每个终端节点或服务都会在您的子网中创建弹性网络接口 (Elastic Network Interface - ENI)——消耗额外的 IP 地址。&lt;/li>
&lt;li>&lt;strong>混合云 (Hybrid Cloud) 增长&lt;/strong>：多 VPC 和多账户网络意味着重叠的 CIDR 块会破坏对等连接和中转网关集成。&lt;/li>
&lt;li>&lt;strong>IPv4 稀缺性&lt;/strong>：您不能再将私有地址空间视为无限，尤其是在大型组织中。&lt;/li>
&lt;/ul>
&lt;h3 id="ipv4-耗尽与弹性-ip-经济学">IPv4 耗尽与弹性 IP 经济学
&lt;/h3>&lt;p>2024 年 2 月，AWS 提高了闲置弹性 IP (Elastic IP) 的收费。到 2025 年年中，&lt;strong>公共 IPv4 地址将成为稀缺资源&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>您现在应该怎么做：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>除非绝对必要，否则停止分配公有 IP 地址 (Public IP Address)&lt;/li>
&lt;li>使用 NAT 网关 (NAT Gateway)，但要平衡成本（或者在小型环境中使用 NAT 实例 (NAT Instance)）&lt;/li>
&lt;li>利用 AWS PrivateLink 和 VPC 终端节点 (VPC Endpoint) 完全避免公开暴露&lt;/li>
&lt;li>开始使用 AWS Network Firewall 和 Route 53 测试 IPv6 入站/出站流量&lt;/li>
&lt;/ul>
&lt;h3 id="aws-5-个-ip-地址规则鲜为人知的细节">AWS 5 个 IP 地址规则（鲜为人知的细节）
&lt;/h3>&lt;p>无论您选择何种 CIDR，您都&lt;strong>永远无法使用子网中的所有 IP 地址&lt;/strong>。
AWS &lt;strong>在每个子网中保留 5 个 IP 地址&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>保留的 IP 地址：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>第一个 IP&lt;/strong> → 网络 ID（定义子网）&lt;/li>
&lt;li>&lt;strong>第二个 IP&lt;/strong> → 默认 VPC 路由器（网关）&lt;/li>
&lt;li>&lt;strong>第三个 IP&lt;/strong> → 由 AWS 保留（内部用途）&lt;/li>
&lt;li>&lt;strong>最后一个 IP&lt;/strong> → 广播地址（RFC 标准，未使用但已保留）&lt;/li>
&lt;li>&lt;strong>额外一个&lt;/strong> → AWS 内部未来使用&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>计算示例：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>/24&lt;/code> = 总计 256 个 → 251 个可用&lt;/li>
&lt;li>&lt;code>/28&lt;/code> = 总计 16 个 → 11 个可用&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>在设计跨可用区 (Availability Zone - AZ) 的高可用性时，应平均划分 CIDR 范围，&lt;strong>并&lt;/strong>在估算容量之前减去 AWS 保留的地址。&lt;/em>&lt;/p>&lt;/blockquote>
&lt;h3 id="2025-年的实际陷阱">2025 年的实际陷阱
&lt;/h3>&lt;p>以下是我看到工程师（甚至经验丰富的工程师）仍然会犯错的地方：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>错误做法&lt;/th>
&lt;th>影响&lt;/th>
&lt;th>解决方案&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>为小型应用选择 &lt;code>/16&lt;/code>&lt;/td>
&lt;td>浪费 IP 空间，在对等连接中造成重叠&lt;/td>
&lt;td>使用 &lt;code>/24&lt;/code> 或 &lt;code>/23&lt;/code> 合理调整大小&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>忽略容器 IP 需求&lt;/td>
&lt;td>EKS 在部署中途耗尽 IP&lt;/td>
&lt;td>使用前缀委托或 CNI 自定义网络&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VPC 之间 CIDR 重叠&lt;/td>
&lt;td>对等连接/TGW 路由中断&lt;/td>
&lt;td>使用 AWS IPAM 进行组织级管理&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在生产中使用过小的 &lt;code>/28&lt;/code>&lt;/td>
&lt;td>IP 耗尽导致扩展事件失败&lt;/td>
&lt;td>为增长预留 20-30% 缓冲&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>忘记 AWS 保留 IP&lt;/td>
&lt;td>服务启动意外失败&lt;/td>
&lt;td>在规划中始终减去 5-IP 规则&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="现代扩展注意事项">现代扩展注意事项
&lt;/h3>&lt;p>到 2025 年，占用 IP 地址的不再仅仅是 EC2。您的计划必须考虑：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Amazon EKS/ECS&lt;/strong> → 默认情况下，每个 pod/任务一个 IP 地址。&lt;/li>
&lt;li>&lt;strong>NAT 网关&lt;/strong> → 每个可用区预留多个 IP 地址用于扩展。&lt;/li>
&lt;li>&lt;strong>VPC 终端节点 (PrivateLink)&lt;/strong> → 创建弹性网络接口 (Elastic Network Interface - ENI)，占用每个可用区中的 IP 地址。&lt;/li>
&lt;li>&lt;strong>负载均衡器 (应用负载均衡器 ALB/网络负载均衡器 NLB)&lt;/strong> → 每个可用区的每个子网都需要 ENI。&lt;/li>
&lt;li>&lt;strong>AWS Lattice 服务&lt;/strong> → 为服务间网络分配 IP 地址。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>在 EKS 中，启用&lt;strong>前缀委托 (Prefix Delegation)&lt;/strong>，以便 pod 共享 /28 前缀而不是获取唯一的 IP 地址 — 从而减少消耗。&lt;/em>&lt;/p>&lt;/blockquote>
&lt;h3 id="安全与影响范围">安全与影响范围
&lt;/h3>&lt;p>CIDR 规划也是一种&lt;strong>安全控制措施&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>更小、特定用途的子网可以在遭受攻击时限制影响范围。&lt;/li>
&lt;li>通过 CIDR 而不仅仅是安全组 (Security Group) 来分段工作负载。&lt;/li>
&lt;li>示例：&lt;code>/28&lt;/code> 用于公有 ALB 层，&lt;code>/24&lt;/code> 用于私有应用服务器，&lt;code>/26&lt;/code> 用于数据库层。&lt;/li>
&lt;/ul>
&lt;h3 id="混合云与多账户网络">混合云与多账户网络
&lt;/h3>&lt;p>CIDR 重叠 = 无法在网络之间路由。&lt;/p>
&lt;p>通过以下方式避免这种情况：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;strong>AWS VPC IP 地址管理器 (IPAM)&lt;/strong> 集中分配 CIDR。&lt;/li>
&lt;li>为开发/生产/预发布 (dev/prod/staging) 遵循&lt;strong>保留范围策略&lt;/strong>。&lt;/li>
&lt;li>为所有 AWS 账户和本地网络保留一份记录完整的&lt;strong>IP 分配图&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="可观测性与故障排除">可观测性与故障排除
&lt;/h3>&lt;p>IP 相关问题可能导致静默故障。优秀的工程师会：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;strong>VPC 流日志 (VPC Flow Logs)&lt;/strong> (在子网或 ENI 级别)&lt;/li>
&lt;li>启用 &lt;strong>CloudWatch Logs Insights&lt;/strong> 查询以进行 IP 级别故障排除&lt;/li>
&lt;li>使用 &lt;strong>可达性分析器 (Reachability Analyzer)&lt;/strong> 在更改前模拟数据包流&lt;/li>
&lt;li>使用 &lt;strong>网络访问分析器 (Network Access Analyzer)&lt;/strong> 持续验证最小权限网络&lt;/li>
&lt;/ul>
&lt;h3 id="aws-vpc-和无人提及的-ip-地址秘密">AWS VPC 和无人提及的 IP 地址秘密
&lt;/h3>&lt;h3 id="图-1-aws-子网中的-5-ip-规则">图 1: AWS 子网中的 5-IP 规则
&lt;/h3>&lt;p>&lt;img src="https://martinliu.cn/blog/aws-vpc-ip-address-secrets-what-every-engineer/1_j-NeuXZTzPTiko4rkOvqOw.webp"
width="640"
height="960"
srcset="https://martinliu.cn/blog/aws-vpc-ip-address-secrets-what-every-engineer/1_j-NeuXZTzPTiko4rkOvqOw_hu_25076655c3d4d357.webp 480w, https://martinliu.cn/blog/aws-vpc-ip-address-secrets-what-every-engineer/1_j-NeuXZTzPTiko4rkOvqOw_hu_e077b24825e64715.webp 1024w"
loading="lazy"
alt="AWS子网IP保留规则示意图"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="160px"
>&lt;/p>
&lt;p>&lt;em>相同的 5-IP 规则适用于&lt;strong>每个子网&lt;/strong>，无论大小如何。&lt;/em>&lt;/p>
&lt;h3 id="真实案例eks--privatelink-中的-ip-消耗">真实案例：EKS + PrivateLink 中的 IP 消耗
&lt;/h3>&lt;p>场景：&lt;/p>
&lt;ul>
&lt;li>&lt;code>/23&lt;/code> 子网 (总共 512 个 IP，AWS 预留后可用 507 个)&lt;/li>
&lt;li>50 节点 &lt;strong>EKS&lt;/strong> 集群 (默认 CNI，每个节点 20 个 Pod)&lt;/li>
&lt;li>每个可用区 1 个 &lt;strong>NAT 网关 (NAT Gateway)&lt;/strong>&lt;/li>
&lt;li>5 个 &lt;strong>PrivateLink 端点 (PrivateLink endpoints)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IP 分配明细：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>EKS 节点：&lt;/strong> 50 个 IP (每个节点一个)&lt;/li>
&lt;li>&lt;strong>EKS Pod：&lt;/strong> 1,000 个 IP (每个节点 20 个，唯一的 ENI (Elastic Network Interface)) → &lt;em>已超出可用 IP 数量！&lt;/em>&lt;/li>
&lt;li>&lt;strong>NAT 网关：&lt;/strong> 1 个 IP&lt;/li>
&lt;li>&lt;strong>PrivateLink：&lt;/strong> 5 个 IP (每个端点 ENI 一个)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>结果：&lt;/strong>
即使使用 &lt;code>/23&lt;/code>，在集群完全调度之前，IP 就会耗尽。
➡ &lt;strong>解决方案：&lt;/strong> 为 EKS 使用&lt;strong>前缀委托 (prefix delegation)&lt;/strong> 或&lt;strong>自定义网络 (custom networking)&lt;/strong>，以大幅减少每个 Pod 的 IP 消耗。&lt;/p>
&lt;h3 id="适用于-aws-的-cidr-决策框架-2025">适用于 AWS 的 CIDR 决策框架 (2025)
&lt;/h3>&lt;h4 id="step-1--确定您的工作负载配置文件">Step 1 — 确定您的工作负载配置文件
&lt;/h4>&lt;ul>
&lt;li>以 EC2 为主：按实例数量加缓冲大小&lt;/li>
&lt;li>以容器为重：计算 Pod/任务数量 (EKS/ECS)&lt;/li>
&lt;li>以服务为重：计算 NAT、PrivateLink、Lattice 产生的 ENI 数量&lt;/li>
&lt;/ul>
&lt;h4 id="step-2--规划增长">Step 2 — 规划增长
&lt;/h4>&lt;ul>
&lt;li>为扩展事件增加 20–30% 的缓冲&lt;/li>
&lt;li>从一开始就考虑&lt;strong>双栈 (IPv4 + IPv6)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="step-3--避免重叠">Step 3 — 避免重叠
&lt;/h4>&lt;ul>
&lt;li>使用 &lt;strong>AWS IPAM (IP Address Manager)&lt;/strong> 进行组织范围的分配&lt;/li>
&lt;li>为多账户和混合设置记录所有 CIDR&lt;/li>
&lt;/ul>
&lt;h4 id="step-4--从设计上确保安全">Step 4 — 从设计上确保安全
&lt;/h4>&lt;ul>
&lt;li>对公共层使用小 CIDR，对私有层使用大 CIDR&lt;/li>
&lt;li>使用专用 CIDR 分段敏感工作负载&lt;/li>
&lt;/ul>
&lt;h4 id="step-5--考虑扩展性">Step 5 — 考虑扩展性
&lt;/h4>&lt;ul>
&lt;li>选择可以扩展的尺寸 (&lt;code>/24&lt;/code> → &lt;code>/23&lt;/code>)，如果需要&lt;/li>
&lt;li>请记住：您&lt;strong>无法缩小&lt;/strong>，只能增加&lt;/li>
&lt;/ul>
&lt;h3 id="2025-年主要启示">2025 年主要启示
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>5-IP 规则&lt;/strong>仍然适用并将永远适用。&lt;/li>
&lt;li>EKS、PrivateLink 和现代 AWS 服务消耗 IP 的速度远超 EC2 时代的架构。&lt;/li>
&lt;li>&lt;strong>IPAM&lt;/strong> 是您在多 VPC/多账户世界中最好的朋友。&lt;/li>
&lt;li>&lt;strong>IPv6&lt;/strong> 不是可选的 — 现在就开始双栈。&lt;/li>
&lt;li>CIDR 规划不仅关乎&lt;strong>容量&lt;/strong>，更关乎&lt;strong>安全性和可扩展性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="2025-年不可忽视的趋势">2025 年不可忽视的趋势
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>IPv6 Everywhere&lt;/strong>：所有新的 VPC 都应采用双栈 (dual-stack) 模式，以便面向未来。&lt;/li>
&lt;li>&lt;strong>BYOIP (Bring Your Own IP)&lt;/strong>：许多企业正在将 IPv4 地址空间带入 AWS，以避免冲突。&lt;/li>
&lt;li>&lt;strong>Automated IP Allocation&lt;/strong>：IaC (基础设施即代码) 流水线现在集成了 IPAM (IP Address Management)，实现零人工 CIDR 分配。&lt;/li>
&lt;li>&lt;strong>Subnet CIDR Expansion&lt;/strong>：AWS 现在支持无中断地扩展子网 — 如果您提前规划，这将是救星。&lt;/li>
&lt;/ul>
&lt;h3 id="aws-ip-小知识却非常实用">AWS IP 小知识，却非常实用
&lt;/h3>&lt;ul>
&lt;li>您可以稍后向 VPC &lt;strong>添加&lt;/strong> CIDR 块，但&lt;strong>不能缩小&lt;/strong>它们。&lt;/li>
&lt;li>始终预留未来 &lt;strong>2-3 年的增长空间&lt;/strong>。&lt;/li>
&lt;li>某些 AWS 服务（例如 FSx、Directory Service）需要&lt;strong>最小子网大小&lt;/strong>。&lt;/li>
&lt;li>在生产子网容量中保留 20-30% 的余量。&lt;/li>
&lt;li>除了实例，NAT 网关 (NAT Gateway) 和负载均衡器 (Load Balancer) 还会额外占用 IP 地址。&lt;/li>
&lt;/ul>
&lt;h3 id="子网规划速查表">子网规划速查表
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>环境类型&lt;/th>
&lt;th>CIDR&lt;/th>
&lt;th>可用 IP 数&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>沙箱/测试&lt;/td>
&lt;td>&lt;code>/28&lt;/code>&lt;/td>
&lt;td>11&lt;/td>
&lt;td>微小型，短期使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>小型生产&lt;/td>
&lt;td>&lt;code>/24&lt;/code>&lt;/td>
&lt;td>251&lt;/td>
&lt;td>Web 应用，小型数据库&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>大型生产&lt;/td>
&lt;td>&lt;code>/23&lt;/code>&lt;/td>
&lt;td>507&lt;/td>
&lt;td>多层架构 + 扩展&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>服务密集型环境&lt;/td>
&lt;td>&lt;code>/22&lt;/code>&lt;/td>
&lt;td>1019&lt;/td>
&lt;td>多服务，多可用区&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="来自实践的最终建议">来自实践的最终建议
&lt;/h3>&lt;p>下次创建 VPC 时：&lt;/p>
&lt;ol>
&lt;li>除非有实际需求，否则&lt;strong>不要默认使用&lt;/strong> &lt;code>/16&lt;/code>。&lt;/li>
&lt;li>在每个子网中&lt;strong>考虑 5 个 IP 地址规则&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>规划容器、端点和扩展&lt;/strong> — 不仅仅是 EC2。&lt;/li>
&lt;li>&lt;strong>使用 IPAM&lt;/strong> 避免重叠并自动化分配。&lt;/li>
&lt;li>&lt;strong>使用 CIDR 作为边界&lt;/strong>，为安全性进行分段。&lt;/li>
&lt;li>&lt;strong>现在就考虑 IPv6&lt;/strong>，不要等到以后。&lt;/li>
&lt;/ol>
&lt;p>今天几分钟的 IP 规划，可以为你节省未来&lt;strong>数周的昂贵迁移成本&lt;/strong>。&lt;/p>
&lt;h3 id="2025-年-aws-vpc-清单">2025 年 AWS VPC 清单
&lt;/h3>&lt;p>上线前，请验证：&lt;/p>
&lt;ul>
&lt;li>从第一天起就支持双栈 (IPv4 + IPv6)&lt;/li>
&lt;li>跨组织和混合网络无重叠的 CIDR&lt;/li>
&lt;li>私有连接 (VPC 端点 (VPC endpoint)、PrivateLink) 用于内部服务&lt;/li>
&lt;li>最小化公共 IPv4 暴露，并有充分理由&lt;/li>
&lt;li>子网大小与工作负载扩展对齐&lt;/li>
&lt;li>安全组 (Security Group) 和网络 ACL (NACL) 根据使用的 IP 范围进行调整&lt;/li>
&lt;li>已部署可观测性，用于数据包级别的故障排除&lt;/li>
&lt;/ul>
&lt;p>到了 2025 年，AWS VPC 设计不再仅仅是“选择一个 CIDR 并点击创建”那么简单。
它关乎&lt;strong>面向 IPv6 的未来规划，避免代价高昂的 IPv4 陷阱，实现私有优先的连接，以及从第一天起就设计混合/多云环境&lt;/strong>。&lt;/p>
&lt;p>掌握这些虽小但却至关重要细节的工程师——正确的 CIDR 选择、积极主动的 IPv6 设置、私有优先的理念——将是那些构建&lt;strong>弹性、安全且可扩展的云网络&lt;/strong>，并能够经受未来十年考验的人。&lt;/p></description></item><item><title>用这些鲜为人知（且大多数开发者都忽略）的技巧，让你的 Python 代码提速 10 倍</title><link>https://martinliu.cn/blog/i-made-my-python-code-10x-faster-using-these/</link><pubDate>Wed, 27 Aug 2025 16:00:00 +0800</pubDate><guid>https://martinliu.cn/blog/i-made-my-python-code-10x-faster-using-these/</guid><description>&lt;img src="https://martinliu.cn/blog/i-made-my-python-code-10x-faster-using-these/1_JtvDNgonwDl8sRlYYW69kA.webp" alt="Featured image of post 用这些鲜为人知（且大多数开发者都忽略）的技巧，让你的 Python 代码提速 10 倍" />&lt;p>如果你是一名在云计算基础架构 (cloud infrastructure)、SRE (Site Reliability Engineering) 和应用数据科学领域工作的从业者，你一定很欣赏 Python 提供的清晰性和简洁性。无论你是在原型化机器学习模型、编排后端工作流，还是在生产级系统 (production-grade system) 中构建自动化管道，Python 始终是你工具库中的首选。但说实话—— &lt;strong>Python 有时会很慢&lt;/strong>。慢得令人痛苦。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/blog/i-made-my-python-code-10x-faster-using-these/0_VXY46SwRfsnWJKIC.webp"
width="640"
height="360"
srcset="https://martinliu.cn/blog/i-made-my-python-code-10x-faster-using-these/0_VXY46SwRfsnWJKIC_hu_aa960e03568e00c7.webp 480w, https://martinliu.cn/blog/i-made-my-python-code-10x-faster-using-these/0_VXY46SwRfsnWJKIC_hu_dacac778015c9775.webp 1024w"
loading="lazy"
alt="Python"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>然而，你需要了解并牢记的是，&lt;strong>Python 的大多数性能问题都是开发者自己造成的&lt;/strong>。问题不在于语言本身，而在于你使用它的方式。事实上，Python 的瓶颈往往是由被忽视的细节引起的：低效的数据结构 (data structures)、不必要的内存分配 (allocations)、重复的计算 (redundant computations)，或者仅仅是你从其他语言带来的、不完全适用的习惯。&lt;/p>
&lt;p>你可能见过太多的工程师（尤其是在高性能计算 (high-performance computing) 领域之外）低估了一些小决定的成本。比如循环方式不当、内置函数使用效率低下、忽视性能分析 (profiling)，或者过度依赖 Pandas (Pandas) 来执行本可以使用 NumPy (NumPy) 或 Polars (Polars) 提速 50 倍的操作。更别提那些仍然在 Pandas 中使用 &lt;code>apply&lt;/code> 而不是向量化 (vectorization) 的人了。&lt;/p>
&lt;p>在这篇文章中，作者不会谈论你随处可见的那些显而易见的建议，比如&amp;quot;使用 NumPy&amp;quot;或&amp;quot;避免 for 循环&amp;quot;。这些你都听过了。这是一次&lt;strong>深入探讨那些被低估、被忽视、有时甚至有些奇特的技巧，它们能够显著加速你的 Python 代码&lt;/strong>——这些技巧你真希望能早点知道。本文将通过实际案例、你可能没用过（但应该用）的库，以及那些悄悄侵蚀你性能的习惯，为你一一讲解。&lt;/p>
&lt;p>所以，如果你正在处理大型数据管道 (data pipelines)、后端 API (Application Programming Interface)、科学计算 (scientific computing)，甚至是自动化基础架构 (infrastructure) 的工作——并且你觉得 Python 正在拖累你——那么这篇文章就是为你准备的。&lt;/p>
&lt;h2 id="-1-停止使用-rangelen--改用-enumerate">🚀 1. 停止使用 range(len(&amp;hellip;)) — 改用 enumerate
&lt;/h2>&lt;p>这看起来可能微不足道，但在某些紧密的循环中，它却出乎意料地常见且代价高昂：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Slow&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_list&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Faster and more Pythonic&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_list&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用 &lt;code>enumerate&lt;/code>（枚举）可以避免重复的索引和方法调用。它更简洁，并有助于解释器在底层进行更好的优化。&lt;/p>
&lt;h2 id="-2-避免将-list-用于大型集合--改用-arraydeque-或-numpy-数组">⚡ 2. 避免将 list 用于大型集合 — 改用 array、deque 或 numpy 数组
&lt;/h2>&lt;p>Python 列表 (lists) 通用且灵活，但对于大型数值运算来说，它们的&lt;strong>内存效率不高&lt;/strong>且速度不快。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">array&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">array&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">my_array&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1"># Much faster than list for ints&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者更好的是，对数值数据使用 &lt;code>numpy&lt;/code> 或 &lt;code>polars.Series&lt;/code>。NumPy 使用由 C 语言支持的固定类型数组，而 Polars（见下文）是用 Rust 编写的，并针对速度进行了优化。&lt;/p>
&lt;h2 id="-3-使用-functoolslru_cache-加速纯函数">🧠 3. 使用 functools.lru_cache 加速纯函数
&lt;/h2>&lt;p>如果你有计算开销大的纯函数（即，相同输入 → 相同输出），记忆化 (memoization) 可以带来显著的性能提升：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">functools&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">lru_cache&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@lru_cache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maxsize&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">expensive_computation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这在许多机器学习 (Machine Learning) 管线中被严重低估。&lt;/p>
&lt;h2 id="-4-使用-numba-将-python-编译成机器码--无需更改代码">🏁 4. 使用 Numba 将 Python 编译成机器码 — 无需更改代码
&lt;/h2>&lt;p>这是一个改变游戏规则的工具。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">numba&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">jit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@jit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nopython&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">compute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>被 &lt;code>@jit&lt;/code> 包装的函数可以运行得&lt;strong>快 100 倍&lt;/strong>。Numba 使用 LLVM 编译你的代码，只需极少的语法改动。它最适用于循环和数值计算代码。&lt;/p>
&lt;h2 id="-5-将-pandas-切换到-polars-处理-dataframe">⚙️ 5. 将 Pandas 切换到 Polars 处理 DataFrame
&lt;/h2>&lt;p>Pandas 很棒。但对于大型数据集来说，它速度慢且是单线程的。此时，让开发者引入 &lt;code>[Polars](https://pola.rs/)&lt;/code>，一个用 Rust 编写并支持原生多线程的极速 DataFrame 库。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">polars&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">pl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">df&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pl&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read_csv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;data.csv&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">df&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">df&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">filter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pl&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;sales&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在实际的 ETL (Extract, Transform, Load) 管线中，Polars 的性能可以比 Pandas &lt;strong>高 10 倍甚至更多&lt;/strong>。&lt;/p>
&lt;h2 id="-6-使用内置性能分析工具--不要盲目优化">🔍 6. 使用内置性能分析工具 — 不要盲目优化
&lt;/h2>&lt;p>在优化任何东西之前，请先进行&lt;strong>性能分析 (Profiling)&lt;/strong>。你无法改进无法衡量的事物。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">python -m cProfile my_script.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者更好的是，使用 &lt;code>line_profiler&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install line_profiler
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@profile&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">my_func&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后使用以下命令运行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kernprof -l my_script.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">python -m line_profiler my_script.py.lprof
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这显示了逐行的瓶颈，是性能调试 (Performance Debugging) 的利器。&lt;/p>
&lt;h2 id="-7-在紧密循环中最小化属性查找">⛏️ 7. 在紧密循环中最小化属性查找
&lt;/h2>&lt;p>这一个细微但非常真实：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Bad&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">some_attribute&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Better&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">attr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">some_attribute&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">attr&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每一次属性访问 (attribute access) 都是一次字典查找 (dictionary lookup)。在大型循环中，这会累积起来。&lt;/p>
&lt;h2 id="-8-预分配列表而不是在循环中追加">🧬 8. 预分配列表而不是在循环中追加
&lt;/h2>&lt;p>追加操作方便，但在大规模操作时会很慢：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Slow&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Faster&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kc">None&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这在数据预处理中尤为重要。&lt;/p>
&lt;h2 id="-9-尝试-pydantic-v2-或-msgspec-进行快速数据验证">📦 9. 尝试 Pydantic V2 (或 msgspec) 进行快速数据验证
&lt;/h2>&lt;p>如果你正在构建 API (Application Programming Interface) 或摄取数据，你可能正在使用 Pydantic。但 v2 &lt;strong>用 Rust 重写&lt;/strong>，速度快得多：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">pydantic&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">BaseModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">BaseModel&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者，为了极致性能：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">msgspec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msgspec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Struct&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>msgspec&lt;/code> 比 Pydantic 和 dataclasses 都快。&lt;/p>
&lt;h2 id="-10-尽可能使用生成器而不是列表">🧪 10. 尽可能使用生成器而不是列表
&lt;/h2>&lt;p>如果你不需要一次性获取所有结果，请使用生成器 (Generators)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">slow&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fast&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>内存使用量将从千兆字节降到几乎为零。&lt;/p>
&lt;h2 id="-额外提示使用-mypyc-编译你的脚本-实验性但有前景">⚙️ 额外提示：使用 mypyc 编译你的脚本 (实验性但有前景)
&lt;/h2>&lt;p>如果你的模块中使用了类型提示 (type hints)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install mypy mypyc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Compiles your script to C extension&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mypyc my_module.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这对于数值计算代码尤其强大，而且如果你已经在使用类型标注 (typing)，只需要进行极小的改动。&lt;/p>
&lt;h2 id="最终思考">最终思考
&lt;/h2>&lt;p>大多数开发者认为 Python 运行缓慢。然而，如果使用得当，Python 的速度会&lt;strong>出人意料地快&lt;/strong>。真正的瓶颈不在于语言本身，而在于我们的使用习惯。通过结合智能利用原生特性、未被充分利用的库以及性能优先的思维模式，我们可以在高吞吐量的生产工作负载中，也能实现全新的速度水平。&lt;/p>
&lt;p>在自己的案例中，优化了生产环境中几个关键的推理评分和数据转换流水线，将运行时间从&lt;strong>数分钟缩短到数秒&lt;/strong>。最棒的是什么？不要更换语言，也不要用 C++ 重写一切。你只需要开始将 Python 视为它本应有的强大语言——只要使用得当。&lt;/p>
&lt;p>如果你认真想要从 Python 中榨取性能，请从这些建议开始。然后进行性能分析 (profile)、测试，并持续学习。总会有更快的方法。&lt;/p></description></item><item><title>探究改变了整个行业的全球开源大潮</title><link>https://martinliu.cn/blog/elastic-university-campus-intro/</link><pubDate>Tue, 27 Apr 2021 09:48:32 +0800</pubDate><guid>https://martinliu.cn/blog/elastic-university-campus-intro/</guid><description>&lt;img src="https://martinliu.cn/img/cos/2021-04-27-opensource.jpg" alt="Featured image of post 探究改变了整个行业的全球开源大潮" />&lt;p>开源科普讲座简介：这是给大学校园的老师和同学们定制的免费公益讲座。在最近的20年里，开源软件已经了席卷全球。当今企业应用开源技术和云计算创作着巨大的社会和商业价值，大学生应该怎样了解、学习和参与开源技术？这成了所有相关学科的同学们不可规避的话题。我们想通过这样一个专题讲座交流的形式，帮助大家按照从由来到未来发展的逻辑梳理开源软件技术的发展。结合我（刘征）20年的外企工作经历，帮助大家深度剖析一家典型的来起源于开源社区的公司，通过这个公司的变迁我们可以看到开源企业所能取得的成功和面临的挑战。Elastic Stack 这个技术栈的核心是 Elasticsearch，这是一个被广泛深度应用的开源大数据搜索平台，中国的一线互联网公司的各种流行产品的背后也都有着它的身影，让我们一起简单理解一下这个技术栈的使用方法，希望它能在校园的研究工作、同学的毕业设计项目等等方面有所帮助。本讲座是注重IT知识的非商业宣传讲座，为了有助于增加同学们的就业竞争力，在最后一个是交流互动环节，我们可以做一些就业形势、求职和职业发展等方面的答疑。&lt;/p>
&lt;p>下面是本次交流见过的概要内容介绍，希望能引起大家的兴趣，如果有任何建议和疑问也可以随时和我直接联系。&lt;/p>
&lt;h2 id="开源用20年改变了整个it行业">开源用20年改变了整个IT行业
&lt;/h2>&lt;p>开源方式是在开源社区内进行思考和协作的一种形式。这一理念基于知识自由和核心原则：透明、协作、交付、包容和社区。社区的思想交流和软件开发推动了以下行业的创新、科学和技术进步：教育、政府、法律、医疗保健和制造业。这项活动提供了一种通过源代码协作、共享和协助实现个人及团体目标的方式。&lt;/p>
&lt;p>开源软件是协作性的，依靠社区生产和同行评审来使用、更改和共享源代码。开发人员分享洞察、构想和代码，共同和单独创建更多创新的软件解决方案。这种可扩展且灵活的软件可确保任何拥有源代码的人都能将其修改、增强和重新分发，从而提高可复用性和可访问性。开源软件基于对等生产和大规模协作的基本原则，从而为最终用户创造更可持续的软件开发体验。&lt;/p>
&lt;p>封源软件 (CSS) 是不向公众分发的专有软件。这类软件进行了加密，因此仅创建该代码的原始作者有权合法复制、修改、更新和编辑源代码。闭源软件会限制最终用户对应用可以执行的操作，防止用户修改、共享、复制或重新发布源代码。&lt;/p>
&lt;p>除了开源和闭源软件之外，FOSS（自由和开源软件）允许用户从更有哲理的角度访问软件。在自由和开源软件中，自由软件基金会 (FSF) 保护用户自由，开源促进会 (OSI) 确保可靠软件的技术价值。有各种各样的免费软件许可证，可供商业使用、修改和销售，包括：GPL、LGPL 和 BSD 许可证。&lt;/p>
&lt;p>一些最受欢迎的开源软件许可证包括：&lt;/p>
&lt;ul>
&lt;li>MIT 许可证©：MIT 许可证是一种免费的软件许可证，允许用户修改原始代码，而且限制要求非常少。&lt;/li>
&lt;li>GNU General Public© (GPL)：GNU 是一系列免费的软件许可证，可确保最终用户能够运行、研究、共享和修改软件。&lt;/li>
&lt;li>Apache®：Apache License 2.0 是一种免费的软件许可证，允许用户出于任何目的使用、修改和分发软件。&lt;/li>
&lt;li>BSD：此许可证对开发人员的限制较少，允许用户使用和修改代码而不必共享修改。&lt;/li>
&lt;li>MySQL™：MySQL 是一个开源数据库管理系统，具有两个单独的许可证 - mySQL Standard Edition 和 MySQL Enterprise Edition。&lt;/li>
&lt;li>SUSE：SUSE Linux 建立在开源 Linux 内核上，并随系统和应用软件一起分发。&lt;/li>
&lt;li>Ubuntu®：Ubuntu 是一个 Linux 发行版，由在桌面、云端和物联网中发布的免费和开源软件组成。&lt;/li>
&lt;/ul>
&lt;p>开源软件大事记：&lt;/p>
&lt;ol>
&lt;li>在 1969 年 AT&amp;amp;T® 贝尔实验室，Unix 做为一种专有但可许可的产品诞生。很快加州大学伯克利分校开发了自己的 Unix 操作系统，名为 Berkley Software Distribution（BSD 许可证）的学术版本。BSD 和 AT&amp;amp;T 的 System V 版最终合并成为统一的第七版 Unix，然后进一步演进为：Sun Solaris、FreeBSD、NetBSD 和 OpenBSD。&lt;/li>
&lt;li>1984 年，Richard Stallman 创建了一个名为 GNU (GNU&amp;rsquo;s Not Unix) 的自由 Unix 克隆。此版本是开放的，可根据需要自由使用、修改和重新分发。Richard Stallman 是 Open Source 界的伟大人物之一, 他是gcc, gdb, emacs的作者。&lt;/li>
&lt;li>1991 年，Linus Torvalds 创建了名为“Linux”或 Linux 内核的操作系统内核。通过与 FSF 和 BSD 组件相结合，Linux 成为一个完整的操作系统。Linux 正式踏上了颠覆整个 IT 行业和改造这个世界的使命，知道今天无不知，无人不晓的云计算和智能硬件，知道工业物联网和火星登录计划。&lt;/li>
&lt;/ol>
&lt;h2 id="市值过百亿的-elastic-公司曲折的开源旅程">市值过百亿的 Elastic 公司曲折的开源旅程
&lt;/h2>&lt;p>Elastic 公司的开源故事起源于创始人 Shay 和妻子的菜谱的故事。现在 Elastic 是一家员工进 2000 人的上市公司，它帮助企业实时大规模地使用数据，完成企业搜索，确保可观测性和安全。Elastic 解决方案基于一个免费的开放技术栈。该技术栈可以部署在任何地方，帮助用户从任何类型的数据中快速获取可作为行动依据的洞见，从搜索文档一直到监控基础架构，再到检测网络攻击威胁。全球各地已有数千家企业利用Elastic 解决方案来支持关键任务系统，包括思科、Goldman Sachs、微软、The Mayo Clinic、NASA、《纽约时报》、维基百科和Verizon等等。Elastic 成立于2012年，已在纽约证券交易所（NYSE）上市，股票代码为ESTC。今天它的股票市值已经超过百亿，从开源开放，到免费开放；从 Appache v2 许可到 Elastic V2 + SSPL 许可，在最近短短的 3 年里到底这家公司都经历了什么？这家公司的开源历程能给予我们怎样的启发？&lt;/p>
&lt;h2 id="轻松入手-elastic-stack-搜索技术栈">轻松入手 Elastic Stack 搜索技术栈
&lt;/h2>&lt;p>Elastic Stack 技术栈包含了一组开源项目。 “ELK”是三个重要组成开源项目的首字母缩写，这三个项目分别是：Elasticsearch、Logstash 和 Kibana。Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。&lt;/p>
&lt;p>&lt;img src="https://www.elastic.co/static-res/images/elk/elk-stack-elkb-diagram.svg"
loading="lazy"
>&lt;/p>
&lt;p>Elastic Stack 就是 ELK Stack，但是更加灵活，可以帮助人们出色完成各项事务。下面我们演示一下内容：&lt;/p>
&lt;ol>
&lt;li>Elasticsearch 和 Kibana 的安装&lt;/li>
&lt;li>使用 Kibana 可视化分析和展示航公公司航班信息、电商平台订单和Web 网络服务器的日志。&lt;/li>
&lt;li>导入最近几年的电影数据，尝试从多个角度分析和展示这些数据&lt;/li>
&lt;/ol>
&lt;h2 id="开源及就业答疑">开源及就业答疑
&lt;/h2>&lt;p>在这个环节里，我们也准备了一些求职准备的经验技巧。&lt;/p>
&lt;ul>
&lt;li>软件专业学生如何构建无敌求职简历&lt;/li>
&lt;li>软件行业里工作岗位的分工和配合&lt;/li>
&lt;li>在 996 和 007 的企业中工作是怎样的体验&lt;/li>
&lt;/ul>
&lt;p>最后，希望和同学们做自由交流，内容范围和问题不限。&lt;/p>
&lt;p>参考文档：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.ibm.com/cn-zh/topics/open-source" target="_blank" rel="noopener"
>https://www.ibm.com/cn-zh/topics/open-source&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.elastic.co/cn/" target="_blank" rel="noopener"
>https://www.elastic.co/cn/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.elastic.co/cn/what-is/elk-stack" target="_blank" rel="noopener"
>https://www.elastic.co/cn/what-is/elk-stack&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://ld.sogou.com/article/i5634372.htm?ch=lds.pc.sh.media.all" target="_blank" rel="noopener"
>https://ld.sogou.com/article/i5634372.htm?ch=lds.pc.sh.media.all&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.163.com/dy/article/G0NG79CD0543QP26.html" target="_blank" rel="noopener"
>https://www.163.com/dy/article/G0NG79CD0543QP26.html&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>
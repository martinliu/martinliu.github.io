<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clippings on Martin Liu's Blog</title><link>https://martinliu.cn/tags/clippings/</link><description>Recent content in Clippings on Martin Liu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 28 Aug 2025 16:07:06 +0800</lastBuildDate><atom:link href="https://martinliu.cn/tags/clippings/index.xml" rel="self" type="application/rss+xml"/><item><title>AWS VPC 和 IP Address 的秘密：2025 年DevOps工程师必知</title><link>https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/</link><pubDate>Wed, 13 Aug 2025 00:00:00 +0000</pubDate><guid>https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/</guid><description>&lt;p>像专家一样学习 AWS VPC IP 地址分配。探索隐藏规则、专家技巧和 2025 年最佳实践，以设计安全、可扩展的 AWS 网络。DevOps 和云工程师的完美指南。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/1_S9_CChjGu1uWc_wnNUGxzw.webp"
width="640"
height="427"
srcset="https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/1_S9_CChjGu1uWc_wnNUGxzw_hu_43cf6306b0505cd0.webp 480w, https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/1_S9_CChjGu1uWc_wnNUGxzw_hu_f9c098888495e4e1.webp 1024w"
loading="lazy"
alt="AWS VPC IP地址配置示意图"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="359px"
>&lt;/p>
&lt;p>当大多数工程师启动一个新的 &lt;strong>AWS 虚拟私有云 (Virtual Private Cloud - VPC)&lt;/strong> 时，他们会直接选择经典的 &lt;code>**/16**&lt;/code> CIDR 块。
为什么？因为它“感觉很安全”——&lt;strong>65,536 个 IP 地址&lt;/strong>都在一个整齐的范围内。
不缺地址，没有规划烦恼……至少看起来是这样。&lt;/p>
&lt;p>但现实是：在 AWS 网络中，&lt;strong>CIDR 块大小的选择并非一劳永逸&lt;/strong>。错误的决策可能导致 &lt;strong>IP 地址耗尽、集成失败、安全漏洞和痛苦的迁移&lt;/strong>。而且，AWS 仍然隐藏着&lt;strong>一个小的 IP 秘密&lt;/strong>，这个秘密总是让新工程师头疼。&lt;/p>
&lt;h3 id="2025-年-cidr-范围规划为何更加重要">2025 年 CIDR 范围规划为何更加重要
&lt;/h3>&lt;p>您的 VPC CIDR 范围定义了您&lt;strong>有多少私有 IP 地址&lt;/strong>——以及这些地址如何被使用、划分并与其他网络集成。&lt;/p>
&lt;p>太多工程师仍然选择 &lt;code>10.0.0.0/16&lt;/code>，然后就此作罢。问题出在哪里？&lt;/p>
&lt;ul>
&lt;li>与企业本地网络重叠&lt;/li>
&lt;li>在 VPC 对等连接 (VPC Peering) 或中转网关 (Transit Gateway) 期间与其他 AWS 账户发生冲突&lt;/li>
&lt;li>当您扩展到多个区域时限制了增长&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2025 年最佳实践：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>创造性地使用 &lt;strong>RFC 1918&lt;/strong> 范围 (&lt;code>172.16.0.0/12&lt;/code> 或 &lt;code>192.168.0.0/16&lt;/code>)&lt;/li>
&lt;li>不要将 RFC 6598 (100.64.0.0/10) 用于 AWS VPC 或企业私有工作负载，它已被 ISP 保留用于运营商级 NAT (Carrier-Grade NAT)（根据 RFC 6598）。请坚持使用 RFC 1918 范围进行 VPC 设计。&lt;/li>
&lt;li>在&lt;strong>组织层面&lt;/strong>而非每个团队层面记录和预留 CIDR 块&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CIDR Block&lt;/th>
&lt;th>Total IPs&lt;/th>
&lt;th>Usable IPs (After AWS Reserve)&lt;/th>
&lt;th>Best For&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>/16&lt;/code>&lt;/td>
&lt;td>65,536&lt;/td>
&lt;td>65,531&lt;/td>
&lt;td>Massive multi-service environments&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>/24&lt;/code>&lt;/td>
&lt;td>256&lt;/td>
&lt;td>251&lt;/td>
&lt;td>Small production workloads&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>/28&lt;/code>&lt;/td>
&lt;td>16&lt;/td>
&lt;td>11&lt;/td>
&lt;td>Test/Sandbox&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>为什么这个选择在今天比以往任何时候都更重要：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>容器 (Containers) 和微服务 (Microservices)&lt;/strong>：在 EKS 和 ECS 中，&lt;strong>每个 Pod/任务 (pod/task) 都会获得自己的 IP&lt;/strong>（默认情况下），这使得小规模子网会 &lt;em>很快&lt;/em> 被占满。&lt;/li>
&lt;li>&lt;strong>AWS PrivateLink 和 VPC Lattice&lt;/strong>：每个终端节点或服务都会在您的子网中创建弹性网络接口 (Elastic Network Interface - ENI)——消耗额外的 IP 地址。&lt;/li>
&lt;li>&lt;strong>混合云 (Hybrid Cloud) 增长&lt;/strong>：多 VPC 和多账户网络意味着重叠的 CIDR 块会破坏对等连接和中转网关集成。&lt;/li>
&lt;li>&lt;strong>IPv4 稀缺性&lt;/strong>：您不能再将私有地址空间视为无限，尤其是在大型组织中。&lt;/li>
&lt;/ul>
&lt;h3 id="ipv4-耗尽与弹性-ip-经济学">IPv4 耗尽与弹性 IP 经济学
&lt;/h3>&lt;p>2024 年 2 月，AWS 提高了闲置弹性 IP (Elastic IP) 的收费。到 2025 年年中，&lt;strong>公共 IPv4 地址将成为稀缺资源&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>您现在应该怎么做：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>除非绝对必要，否则停止分配公有 IP 地址 (Public IP Address)&lt;/li>
&lt;li>使用 NAT 网关 (NAT Gateway)，但要平衡成本（或者在小型环境中使用 NAT 实例 (NAT Instance)）&lt;/li>
&lt;li>利用 AWS PrivateLink 和 VPC 终端节点 (VPC Endpoint) 完全避免公开暴露&lt;/li>
&lt;li>开始使用 AWS Network Firewall 和 Route 53 测试 IPv6 入站/出站流量&lt;/li>
&lt;/ul>
&lt;h3 id="aws-5-个-ip-地址规则鲜为人知的细节">AWS 5 个 IP 地址规则（鲜为人知的细节）
&lt;/h3>&lt;p>无论您选择何种 CIDR，您都&lt;strong>永远无法使用子网中的所有 IP 地址&lt;/strong>。
AWS &lt;strong>在每个子网中保留 5 个 IP 地址&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>保留的 IP 地址：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>第一个 IP&lt;/strong> → 网络 ID（定义子网）&lt;/li>
&lt;li>&lt;strong>第二个 IP&lt;/strong> → 默认 VPC 路由器（网关）&lt;/li>
&lt;li>&lt;strong>第三个 IP&lt;/strong> → 由 AWS 保留（内部用途）&lt;/li>
&lt;li>&lt;strong>最后一个 IP&lt;/strong> → 广播地址（RFC 标准，未使用但已保留）&lt;/li>
&lt;li>&lt;strong>额外一个&lt;/strong> → AWS 内部未来使用&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>计算示例：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>/24&lt;/code> = 总计 256 个 → 251 个可用&lt;/li>
&lt;li>&lt;code>/28&lt;/code> = 总计 16 个 → 11 个可用&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>在设计跨可用区 (Availability Zone - AZ) 的高可用性时，应平均划分 CIDR 范围，&lt;strong>并&lt;/strong>在估算容量之前减去 AWS 保留的地址。&lt;/em>&lt;/p>&lt;/blockquote>
&lt;h3 id="2025-年的实际陷阱">2025 年的实际陷阱
&lt;/h3>&lt;p>以下是我看到工程师（甚至经验丰富的工程师）仍然会犯错的地方：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Mistake&lt;/th>
&lt;th>Impact&lt;/th>
&lt;th>Solution&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Picking &lt;code>/16&lt;/code> for small apps&lt;/td>
&lt;td>Wastes IP space, causes overlap in peering&lt;/td>
&lt;td>Right-size using &lt;code>/24&lt;/code> or &lt;code>/23&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ignoring container IP needs&lt;/td>
&lt;td>EKS runs out of IPs mid-deploy&lt;/td>
&lt;td>Use prefix delegation or CNI custom networking&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Overlapping CIDRs between VPCs&lt;/td>
&lt;td>Peering/TGW routing breaks&lt;/td>
&lt;td>Use AWS IPAM to manage org-wide&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Using tiny &lt;code>/28&lt;/code> in prod&lt;/td>
&lt;td>IP exhaustion kills scaling events&lt;/td>
&lt;td>Leave 20–30% buffer for growth&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Forgetting AWS reserves IPs&lt;/td>
&lt;td>Service launches fail unexpectedly&lt;/td>
&lt;td>Always subtract the 5-IP rule in planning&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="现代扩展注意事项">现代扩展注意事项
&lt;/h3>&lt;p>到 2025 年，占用 IP 地址的不再仅仅是 EC2。您的计划必须考虑：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Amazon EKS/ECS&lt;/strong> → 默认情况下，每个 pod/任务一个 IP 地址。&lt;/li>
&lt;li>&lt;strong>NAT 网关&lt;/strong> → 每个可用区预留多个 IP 地址用于扩展。&lt;/li>
&lt;li>&lt;strong>VPC 终端节点 (PrivateLink)&lt;/strong> → 创建弹性网络接口 (Elastic Network Interface - ENI)，占用每个可用区中的 IP 地址。&lt;/li>
&lt;li>&lt;strong>负载均衡器 (应用负载均衡器 ALB/网络负载均衡器 NLB)&lt;/strong> → 每个可用区的每个子网都需要 ENI。&lt;/li>
&lt;li>&lt;strong>AWS Lattice 服务&lt;/strong> → 为服务间网络分配 IP 地址。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>在 EKS 中，启用&lt;strong>前缀委托 (Prefix Delegation)&lt;/strong>，以便 pod 共享 /28 前缀而不是获取唯一的 IP 地址 — 从而减少消耗。&lt;/em>&lt;/p>&lt;/blockquote>
&lt;h3 id="安全与影响范围">安全与影响范围
&lt;/h3>&lt;p>CIDR 规划也是一种&lt;strong>安全控制措施&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>更小、特定用途的子网可以在遭受攻击时限制影响范围。&lt;/li>
&lt;li>通过 CIDR 而不仅仅是安全组 (Security Group) 来分段工作负载。&lt;/li>
&lt;li>示例：&lt;code>/28&lt;/code> 用于公有 ALB 层，&lt;code>/24&lt;/code> 用于私有应用服务器，&lt;code>/26&lt;/code> 用于数据库层。&lt;/li>
&lt;/ul>
&lt;h3 id="混合云与多账户网络">混合云与多账户网络
&lt;/h3>&lt;p>CIDR 重叠 = 无法在网络之间路由。&lt;/p>
&lt;p>通过以下方式避免这种情况：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;strong>AWS VPC IP 地址管理器 (IPAM)&lt;/strong> 集中分配 CIDR。&lt;/li>
&lt;li>为开发/生产/预发布 (dev/prod/staging) 遵循&lt;strong>保留范围策略&lt;/strong>。&lt;/li>
&lt;li>为所有 AWS 账户和本地网络保留一份记录完整的&lt;strong>IP 分配图&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="可观测性与故障排除">可观测性与故障排除
&lt;/h3>&lt;p>IP 相关问题可能导致静默故障。优秀的工程师会：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;strong>VPC 流日志 (VPC Flow Logs)&lt;/strong> (在子网或 ENI 级别)&lt;/li>
&lt;li>启用 &lt;strong>CloudWatch Logs Insights&lt;/strong> 查询以进行 IP 级别故障排除&lt;/li>
&lt;li>使用 &lt;strong>可达性分析器 (Reachability Analyzer)&lt;/strong> 在更改前模拟数据包流&lt;/li>
&lt;li>使用 &lt;strong>网络访问分析器 (Network Access Analyzer)&lt;/strong> 持续验证最小权限网络&lt;/li>
&lt;/ul>
&lt;h3 id="aws-vpc-和无人提及的-ip-地址秘密">AWS VPC 和无人提及的 IP 地址秘密
&lt;/h3>&lt;h3 id="图-1-aws-子网中的-5-ip-规则">图 1: AWS 子网中的 5-IP 规则
&lt;/h3>&lt;p>&lt;img src="https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/1_j-NeuXZTzPTiko4rkOvqOw.webp"
width="640"
height="960"
srcset="https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/1_j-NeuXZTzPTiko4rkOvqOw_hu_25076655c3d4d357.webp 480w, https://martinliu.cn/blog/aws-vpc-%E5%92%8C-ip-address-%E7%9A%84%E7%A7%98%E5%AF%862025-%E5%B9%B4devops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5/1_j-NeuXZTzPTiko4rkOvqOw_hu_e077b24825e64715.webp 1024w"
loading="lazy"
alt="AWS子网IP保留规则示意图"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="160px"
>&lt;/p>
&lt;p>&lt;em>相同的 5-IP 规则适用于&lt;strong>每个子网&lt;/strong>，无论大小如何。&lt;/em>&lt;/p>
&lt;h3 id="真实案例eks--privatelink-中的-ip-消耗">真实案例：EKS + PrivateLink 中的 IP 消耗
&lt;/h3>&lt;p>场景：&lt;/p>
&lt;ul>
&lt;li>&lt;code>/23&lt;/code> 子网 (总共 512 个 IP，AWS 预留后可用 507 个)&lt;/li>
&lt;li>50 节点 &lt;strong>EKS&lt;/strong> 集群 (默认 CNI，每个节点 20 个 Pod)&lt;/li>
&lt;li>每个可用区 1 个 &lt;strong>NAT 网关 (NAT Gateway)&lt;/strong>&lt;/li>
&lt;li>5 个 &lt;strong>PrivateLink 端点 (PrivateLink endpoints)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IP 分配明细：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>EKS 节点：&lt;/strong> 50 个 IP (每个节点一个)&lt;/li>
&lt;li>&lt;strong>EKS Pod：&lt;/strong> 1,000 个 IP (每个节点 20 个，唯一的 ENI (Elastic Network Interface)) → &lt;em>已超出可用 IP 数量！&lt;/em>&lt;/li>
&lt;li>&lt;strong>NAT 网关：&lt;/strong> 1 个 IP&lt;/li>
&lt;li>&lt;strong>PrivateLink：&lt;/strong> 5 个 IP (每个端点 ENI 一个)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>结果：&lt;/strong>
即使使用 &lt;code>/23&lt;/code>，在集群完全调度之前，IP 就会耗尽。
➡ &lt;strong>解决方案：&lt;/strong> 为 EKS 使用&lt;strong>前缀委托 (prefix delegation)&lt;/strong> 或&lt;strong>自定义网络 (custom networking)&lt;/strong>，以大幅减少每个 Pod 的 IP 消耗。&lt;/p>
&lt;h3 id="适用于-aws-的-cidr-决策框架-2025">适用于 AWS 的 CIDR 决策框架 (2025)
&lt;/h3>&lt;h4 id="step-1--确定您的工作负载配置文件">Step 1 — 确定您的工作负载配置文件
&lt;/h4>&lt;ul>
&lt;li>以 EC2 为主：按实例数量加缓冲大小&lt;/li>
&lt;li>以容器为重：计算 Pod/任务数量 (EKS/ECS)&lt;/li>
&lt;li>以服务为重：计算 NAT、PrivateLink、Lattice 产生的 ENI 数量&lt;/li>
&lt;/ul>
&lt;h4 id="step-2--规划增长">Step 2 — 规划增长
&lt;/h4>&lt;ul>
&lt;li>为扩展事件增加 20–30% 的缓冲&lt;/li>
&lt;li>从一开始就考虑&lt;strong>双栈 (IPv4 + IPv6)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="step-3--避免重叠">Step 3 — 避免重叠
&lt;/h4>&lt;ul>
&lt;li>使用 &lt;strong>AWS IPAM (IP Address Manager)&lt;/strong> 进行组织范围的分配&lt;/li>
&lt;li>为多账户和混合设置记录所有 CIDR&lt;/li>
&lt;/ul>
&lt;h4 id="step-4--从设计上确保安全">Step 4 — 从设计上确保安全
&lt;/h4>&lt;ul>
&lt;li>对公共层使用小 CIDR，对私有层使用大 CIDR&lt;/li>
&lt;li>使用专用 CIDR 分段敏感工作负载&lt;/li>
&lt;/ul>
&lt;h4 id="step-5--考虑扩展性">Step 5 — 考虑扩展性
&lt;/h4>&lt;ul>
&lt;li>选择可以扩展的尺寸 (&lt;code>/24&lt;/code> → &lt;code>/23&lt;/code>)，如果需要&lt;/li>
&lt;li>请记住：您&lt;strong>无法缩小&lt;/strong>，只能增加&lt;/li>
&lt;/ul>
&lt;h3 id="2025-年主要启示">2025 年主要启示
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>5-IP 规则&lt;/strong>仍然适用并将永远适用。&lt;/li>
&lt;li>EKS、PrivateLink 和现代 AWS 服务消耗 IP 的速度远超 EC2 时代的架构。&lt;/li>
&lt;li>&lt;strong>IPAM&lt;/strong> 是您在多 VPC/多账户世界中最好的朋友。&lt;/li>
&lt;li>&lt;strong>IPv6&lt;/strong> 不是可选的 — 现在就开始双栈。&lt;/li>
&lt;li>CIDR 规划不仅关乎&lt;strong>容量&lt;/strong>，更关乎&lt;strong>安全性和可扩展性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="2025-年不可忽视的趋势">2025 年不可忽视的趋势
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>IPv6 Everywhere&lt;/strong>：所有新的 VPC 都应采用双栈 (dual-stack) 模式，以便面向未来。&lt;/li>
&lt;li>&lt;strong>BYOIP (Bring Your Own IP)&lt;/strong>：许多企业正在将 IPv4 地址空间带入 AWS，以避免冲突。&lt;/li>
&lt;li>&lt;strong>Automated IP Allocation&lt;/strong>：IaC (基础设施即代码) 流水线现在集成了 IPAM (IP Address Management)，实现零人工 CIDR 分配。&lt;/li>
&lt;li>&lt;strong>Subnet CIDR Expansion&lt;/strong>：AWS 现在支持无中断地扩展子网 — 如果您提前规划，这将是救星。&lt;/li>
&lt;/ul>
&lt;h3 id="aws-ip-小知识却非常实用">AWS IP 小知识，却非常实用
&lt;/h3>&lt;ul>
&lt;li>您可以稍后向 VPC &lt;strong>添加&lt;/strong> CIDR 块，但&lt;strong>不能缩小&lt;/strong>它们。&lt;/li>
&lt;li>始终预留未来 &lt;strong>2-3 年的增长空间&lt;/strong>。&lt;/li>
&lt;li>某些 AWS 服务（例如 FSx、Directory Service）需要&lt;strong>最小子网大小&lt;/strong>。&lt;/li>
&lt;li>在生产子网容量中保留 20-30% 的余量。&lt;/li>
&lt;li>除了实例，NAT 网关 (NAT Gateway) 和负载均衡器 (Load Balancer) 还会额外占用 IP 地址。&lt;/li>
&lt;/ul>
&lt;h3 id="子网规划速查表">子网规划速查表
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Environment&lt;/th>
&lt;th>CIDR&lt;/th>
&lt;th>Usable IPs&lt;/th>
&lt;th>Notes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Sandbox/Test&lt;/td>
&lt;td>&lt;code>/28&lt;/code>&lt;/td>
&lt;td>11&lt;/td>
&lt;td>Tiny, short-lived&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Small Prod&lt;/td>
&lt;td>&lt;code>/24&lt;/code>&lt;/td>
&lt;td>251&lt;/td>
&lt;td>Web apps, small DBs&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Large Prod&lt;/td>
&lt;td>&lt;code>/23&lt;/code>&lt;/td>
&lt;td>507&lt;/td>
&lt;td>Multi-tier + scaling&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Service-heavy Env&lt;/td>
&lt;td>&lt;code>/22&lt;/code>&lt;/td>
&lt;td>1019&lt;/td>
&lt;td>Many services, multi-AZ&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="来自实践的最终建议">来自实践的最终建议
&lt;/h3>&lt;p>下次创建 VPC 时：&lt;/p>
&lt;ol>
&lt;li>除非有实际需求，否则&lt;strong>不要默认使用&lt;/strong> &lt;code>**/16**&lt;/code>。&lt;/li>
&lt;li>在每个子网中&lt;strong>考虑 5 个 IP 地址规则&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>规划容器、端点和扩展&lt;/strong> — 不仅仅是 EC2。&lt;/li>
&lt;li>&lt;strong>使用 IPAM&lt;/strong> 避免重叠并自动化分配。&lt;/li>
&lt;li>&lt;strong>使用 CIDR 作为边界&lt;/strong>，为安全性进行分段。&lt;/li>
&lt;li>&lt;strong>现在就考虑 IPv6&lt;/strong>，不要等到以后。&lt;/li>
&lt;/ol>
&lt;p>今天几分钟的 IP 规划，可以为你节省未来&lt;strong>数周的昂贵迁移成本&lt;/strong>。&lt;/p>
&lt;h3 id="2025-年-aws-vpc-清单">2025 年 AWS VPC 清单
&lt;/h3>&lt;p>上线前，请验证：&lt;/p>
&lt;ul>
&lt;li>从第一天起就支持双栈 (IPv4 + IPv6)&lt;/li>
&lt;li>跨组织和混合网络无重叠的 CIDR&lt;/li>
&lt;li>私有连接 (VPC 端点 (VPC endpoint)、PrivateLink) 用于内部服务&lt;/li>
&lt;li>最小化公共 IPv4 暴露，并有充分理由&lt;/li>
&lt;li>子网大小与工作负载扩展对齐&lt;/li>
&lt;li>安全组 (Security Group) 和网络 ACL (NACL) 根据使用的 IP 范围进行调整&lt;/li>
&lt;li>已部署可观测性，用于数据包级别的故障排除&lt;/li>
&lt;/ul>
&lt;p>到了 2025 年，AWS VPC 设计不再仅仅是“选择一个 CIDR 并点击创建”那么简单。
它关乎&lt;strong>面向 IPv6 的未来规划，避免代价高昂的 IPv4 陷阱，实现私有优先的连接，以及从第一天起就设计混合/多云环境&lt;/strong>。&lt;/p>
&lt;p>掌握这些虽小但却至关重要细节的工程师——正确的 CIDR 选择、积极主动的 IPv6 设置、私有优先的理念——将是那些构建&lt;strong>弹性、安全且可扩展的云网络&lt;/strong>，并能够经受未来十年考验的人。&lt;/p>
&lt;p>一名 DevOps 工程师，掌握 Docker、Kubernetes、Terraform、AWS 和 CI/CD 技能。自动化工作流程，以提高软件交付和可靠性。&lt;/p></description></item><item><title>用这些鲜为人知（且大多数开发者都忽略）的技巧，让你的 Python 代码提速 10 倍</title><link>https://martinliu.cn/blog/%E7%94%A8%E8%BF%99%E4%BA%9B%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E4%B8%94%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%A9%E4%BD%A0%E7%9A%84-python-%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F-10-%E5%80%8D/</link><pubDate>Tue, 06 May 2025 00:00:00 +0000</pubDate><guid>https://martinliu.cn/blog/%E7%94%A8%E8%BF%99%E4%BA%9B%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E4%B8%94%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%A9%E4%BD%A0%E7%9A%84-python-%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F-10-%E5%80%8D/</guid><description>&lt;p>如果你是一名在云计算基础架构 (cloud infrastructure)、SRE (Site Reliability Engineering) 和应用数据科学领域工作的从业者，你一定很欣赏 Python 提供的清晰性和简洁性。无论你是在原型化机器学习模型、编排后端工作流，还是在生产级系统 (production-grade system) 中构建自动化管道，Python 始终是你工具库中的首选。但说实话—— &lt;strong>Python 有时会很慢&lt;/strong>。慢得令人痛苦。&lt;/p>
&lt;p>&lt;img src="https://martinliu.cn/blog/%E7%94%A8%E8%BF%99%E4%BA%9B%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E4%B8%94%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%A9%E4%BD%A0%E7%9A%84-python-%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F-10-%E5%80%8D/0_VXY46SwRfsnWJKIC.webp"
width="640"
height="360"
srcset="https://martinliu.cn/blog/%E7%94%A8%E8%BF%99%E4%BA%9B%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E4%B8%94%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%A9%E4%BD%A0%E7%9A%84-python-%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F-10-%E5%80%8D/0_VXY46SwRfsnWJKIC_hu_aa960e03568e00c7.webp 480w, https://martinliu.cn/blog/%E7%94%A8%E8%BF%99%E4%BA%9B%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E4%B8%94%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E5%BF%BD%E7%95%A5%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%A9%E4%BD%A0%E7%9A%84-python-%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F-10-%E5%80%8D/0_VXY46SwRfsnWJKIC_hu_dacac778015c9775.webp 1024w"
loading="lazy"
alt="Python"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>然而，你需要了解并牢记的是，&lt;strong>Python 的大多数性能问题都是开发者自己造成的&lt;/strong>。问题不在于语言本身，而在于你使用它的方式。事实上，Python 的瓶颈往往是由被忽视的细节引起的：低效的数据结构 (data structures)、不必要的内存分配 (allocations)、重复的计算 (redundant computations)，或者仅仅是你从其他语言带来的、不完全适用的习惯。&lt;/p>
&lt;p>你可能见过太多的工程师（尤其是在高性能计算 (high-performance computing) 领域之外）低估了一些小决定的成本。比如循环方式不当、内置函数使用效率低下、忽视性能分析 (profiling)，或者过度依赖 Pandas (Pandas) 来执行本可以使用 NumPy (NumPy) 或 Polars (Polars) 提速 50 倍的操作。更别提那些仍然在 Pandas 中使用 &lt;code>apply&lt;/code> 而不是向量化 (vectorization) 的人了。&lt;/p>
&lt;p>在这篇文章中，作者不会谈论你随处可见的那些显而易见的建议，比如&amp;quot;使用 NumPy&amp;quot;或&amp;quot;避免 for 循环&amp;quot;。这些你都听过了。这是一次&lt;strong>深入探讨那些被低估、被忽视、有时甚至有些奇特的技巧，它们能够显著加速你的 Python 代码&lt;/strong>——这些技巧你真希望能早点知道。本文将通过实际案例、你可能没用过（但应该用）的库，以及那些悄悄侵蚀你性能的习惯，为你一一讲解。&lt;/p>
&lt;p>所以，如果你正在处理大型数据管道 (data pipelines)、后端 API (Application Programming Interface)、科学计算 (scientific computing)，甚至是自动化基础架构 (infrastructure) 的工作——并且你觉得 Python 正在拖累你——那么这篇文章就是为你准备的。&lt;/p>
&lt;h2 id="-1-停止使用-rangelen--改用-enumerate">🚀 1. 停止使用 range(len(&amp;hellip;)) — 改用 enumerate
&lt;/h2>&lt;p>这看起来可能微不足道，但在某些紧密的循环中，它却出乎意料地常见且代价高昂：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Slow&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_list&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_list&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Faster and more Pythonic&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_list&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用 &lt;code>enumerate&lt;/code>（枚举）可以避免重复的索引和方法调用。它更简洁，并有助于解释器在底层进行更好的优化。&lt;/p>
&lt;h2 id="-2-避免将-list-用于大型集合--改用-arraydeque-或-numpy-数组">⚡ 2. 避免将 list 用于大型集合 — 改用 array、deque 或 numpy 数组
&lt;/h2>&lt;p>Python 列表 (lists) 通用且灵活，但对于大型数值运算来说，它们的&lt;strong>内存效率不高&lt;/strong>且速度不快。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">array&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">array&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">my_array&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1"># Much faster than list for ints&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者更好的是，对数值数据使用 &lt;code>numpy&lt;/code> 或 &lt;code>polars.Series&lt;/code>。NumPy 使用由 C 语言支持的固定类型数组，而 Polars（见下文）是用 Rust 编写的，并针对速度进行了优化。&lt;/p>
&lt;h2 id="-3-使用-functoolslru_cache-加速纯函数">🧠 3. 使用 functools.lru_cache 加速纯函数
&lt;/h2>&lt;p>如果你有计算开销大的纯函数（即，相同输入 → 相同输出），记忆化 (memoization) 可以带来显著的性能提升：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">functools&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">lru_cache&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@lru_cache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maxsize&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">expensive_computation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这在许多机器学习 (Machine Learning) 管线中被严重低估。&lt;/p>
&lt;h2 id="-4-使用-numba-将-python-编译成机器码--无需更改代码">🏁 4. 使用 Numba 将 Python 编译成机器码 — 无需更改代码
&lt;/h2>&lt;p>这是一个改变游戏规则的工具。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">numba&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">jit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@jit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nopython&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">compute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>被 &lt;code>@jit&lt;/code> 包装的函数可以运行得&lt;strong>快 100 倍&lt;/strong>。Numba 使用 LLVM 编译你的代码，只需极少的语法改动。它最适用于循环和数值计算代码。&lt;/p>
&lt;h2 id="-5-将-pandas-切换到-polars-处理-dataframe">⚙️ 5. 将 Pandas 切换到 Polars 处理 DataFrame
&lt;/h2>&lt;p>Pandas 很棒。但对于大型数据集来说，它速度慢且是单线程的。此时，让开发者引入 &lt;code>[Polars](https://pola.rs/)&lt;/code>，一个用 Rust 编写并支持原生多线程的极速 DataFrame 库。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">polars&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">pl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">df&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pl&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read_csv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;data.csv&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">df&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">df&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">filter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pl&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;sales&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在实际的 ETL (Extract, Transform, Load) 管线中，Polars 的性能可以比 Pandas &lt;strong>高 10 倍甚至更多&lt;/strong>。&lt;/p>
&lt;h2 id="-6-使用内置性能分析工具--不要盲目优化">🔍 6. 使用内置性能分析工具 — 不要盲目优化
&lt;/h2>&lt;p>在优化任何东西之前，请先进行&lt;strong>性能分析 (Profiling)&lt;/strong>。你无法改进无法衡量的事物。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">python -m cProfile my_script.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者更好的是，使用 &lt;code>line_profiler&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install line_profiler
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@profile&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">my_func&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后使用以下命令运行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kernprof -l my_script.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">python -m line_profiler my_script.py.lprof
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这显示了逐行的瓶颈，是性能调试 (Performance Debugging) 的利器。&lt;/p>
&lt;h2 id="-7-在紧密循环中最小化属性查找">⛏️ 7. 在紧密循环中最小化属性查找
&lt;/h2>&lt;p>这一个细微但非常真实：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Bad&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">some_attribute&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Better&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">attr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">some_attribute&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">attr&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每一次属性访问 (attribute access) 都是一次字典查找 (dictionary lookup)。在大型循环中，这会累积起来。&lt;/p>
&lt;h2 id="-8-预分配列表而不是在循环中追加">🧬 8. 预分配列表而不是在循环中追加
&lt;/h2>&lt;p>追加操作方便，但在大规模操作时会很慢：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Slow&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Faster&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kc">None&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这在数据预处理中尤为重要。&lt;/p>
&lt;h2 id="-9-尝试-pydantic-v2-或-msgspec-进行快速数据验证">📦 9. 尝试 Pydantic V2 (或 msgspec) 进行快速数据验证
&lt;/h2>&lt;p>如果你正在构建 API (Application Programming Interface) 或摄取数据，你可能正在使用 Pydantic。但 v2 &lt;strong>用 Rust 重写&lt;/strong>，速度快得多：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">pydantic&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">BaseModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">BaseModel&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者，为了极致性能：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">msgspec&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msgspec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Struct&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>msgspec&lt;/code> 比 Pydantic 和 dataclasses 都快。&lt;/p>
&lt;h2 id="-10-尽可能使用生成器而不是列表">🧪 10. 尽可能使用生成器而不是列表
&lt;/h2>&lt;p>如果你不需要一次性获取所有结果，请使用生成器 (Generators)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">slow&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fast&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>内存使用量将从千兆字节降到几乎为零。&lt;/p>
&lt;h2 id="-额外提示使用-mypyc-编译你的脚本-实验性但有前景">⚙️ 额外提示：使用 mypyc 编译你的脚本 (实验性但有前景)
&lt;/h2>&lt;p>如果你的模块中使用了类型提示 (type hints)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install mypy mypyc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Compiles your script to C extension&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mypyc my_module.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这对于数值计算代码尤其强大，而且如果你已经在使用类型标注 (typing)，只需要进行极小的改动。&lt;/p>
&lt;h2 id="最终思考">最终思考
&lt;/h2>&lt;p>大多数开发者认为 Python 运行缓慢。然而，如果使用得当，Python 的速度会&lt;strong>出人意料地快&lt;/strong>。真正的瓶颈不在于语言本身，而在于我们的使用习惯。通过结合智能利用原生特性、未被充分利用的库以及性能优先的思维模式，我们可以在高吞吐量的生产工作负载中，也能实现全新的速度水平。&lt;/p>
&lt;p>在自己的案例中，优化了生产环境中几个关键的推理评分和数据转换流水线，将运行时间从&lt;strong>数分钟缩短到数秒&lt;/strong>。最棒的是什么？不要更换语言，也不要用 C++ 重写一切。你只需要开始将 Python 视为它本应有的强大语言——只要使用得当。&lt;/p>
&lt;p>如果你认真想要从 Python 中榨取性能，请从这些建议开始。然后进行性能分析 (profile)、测试，并持续学习。总会有更快的方法。&lt;/p></description></item></channel></rss>